{"version":3,"sources":["../src/index.ts","../src/common/debugger.ts","../src/ogg/oggParsing.ts","../src/ogg/oggDisassemble.ts","../src/webm/matroskaTypes.ts","../src/webm/webmParse.ts","../src/webm/webmDisassemble.ts","../src/common/formatDetection.ts","../src/common/disassemble.ts","../src/ogg/oggCrc.ts","../src/ogg/oggWrite.ts","../src/ogg/oggAssemble.ts"],"sourcesContent":["import debug from \"./common/debugger\";\r\nimport { disassembleOpusFile } from \"./common/disassemble\";\r\nimport { assembleOgg } from \"./ogg/oggAssemble\";\r\nimport { findOggStart, parseOggPage } from \"./ogg/oggParsing\";\r\n\r\nexport const setDebug = (enabled: boolean) => {\r\n    debug.isDebug = enabled;\r\n};\r\n\r\nexport const setCustomDebugLogger = (logger: (...args: any[]) => void) => {\r\n    debug.customLogger = logger;\r\n};\r\n\r\n/**\r\n * Concatenate multiple Opus-in-Ogg or Opus-in-WebM files into a single logical bitstream.\r\n * Adjusts page headers, granule positions, and replaces OpusTags.\r\n */\r\nexport const concatenateOpusFiles = async (\r\n    chunks: Uint8Array[],\r\n): Promise<Uint8Array> => {\r\n    if (chunks.length === 0) {\r\n        throw new Error('No chunks provided');\r\n    }\r\n\r\n    // First chunk - prepare it (auto-detects Ogg or WebM)\r\n    const { prepared, meta } = prepareForConcat(chunks[0]);\r\n\r\n    if (chunks.length === 1) {\r\n        return prepared;\r\n    }\r\n\r\n    // Remaining chunks - add them (auto-detects each)\r\n    const { result } = addToAcc(prepared, chunks.slice(1), meta);\r\n\r\n    return result;\r\n};\r\n\r\nexport interface AppendMeta {\r\n    serialNumber: number;\r\n    lastPageSequence: number;\r\n    cumulativeGranule: bigint;\r\n    totalSize: number;\r\n}\r\n\r\n/**\r\n * Parse and prepare an existing Opus file (Ogg or WebM container) for appending\r\n * Returns the prepared file (with EOS cleared, OpusTags replaced) and metadata\r\n * required for concatenation of more files within the same logical bitstream.\r\n */\r\nexport const prepareForConcat = (\r\n    data: Uint8Array\r\n): { prepared: Uint8Array; meta: AppendMeta } => {\r\n    // Disassemble (auto-detects format)\r\n    const stream = disassembleOpusFile(data);\r\n    \r\n    // Assemble into clean Ogg with headers\r\n    const { data: prepared } = assembleOgg(stream, { includeHeaders: true });\r\n    \r\n    // Extract metadata from the prepared file\r\n    const oggStart = findOggStart(prepared);\r\n    let offset = oggStart;\r\n    let lastPageSequence = 0;\r\n    let maxGranule = BigInt(0);\r\n    let serialNumber = stream.serialNumber ?? 0;\r\n    \r\n    while (offset < prepared.length) {\r\n        const page = parseOggPage(prepared, offset);\r\n        if (!page) break;\r\n        \r\n        if (serialNumber === 0) serialNumber = page.serialNumber;\r\n        lastPageSequence = page.pageSequence;\r\n        if (page.granulePosition > maxGranule) {\r\n            maxGranule = page.granulePosition;\r\n        }\r\n        \r\n        offset += page.pageSize;\r\n    }\r\n    \r\n    return {\r\n        prepared,\r\n        meta: {\r\n            serialNumber,\r\n            lastPageSequence,\r\n            cumulativeGranule: maxGranule,\r\n            totalSize: prepared.length,\r\n        }\r\n    };\r\n};\r\n\r\n/**\r\n *  Append new chunks to an existing accumulator\r\n * @param acc File to append to\r\n * @param chunks additional chunks to append, `.opus` (opus-in-ogg) files\r\n * @param accMeta Metadata about the current accumulator state\r\n * @returns Updated accumulator (concatenated Opus file ready for further appending) and metadata for next append\r\n */\r\nexport const addToAcc = (\r\n    acc: Uint8Array,\r\n    chunks: Uint8Array[],\r\n    accMeta: AppendMeta\r\n): { result: Uint8Array; meta: AppendMeta } => {\r\n    const dataPages: Uint8Array[] = [];\r\n    let pageSequence = accMeta.lastPageSequence + 1;\r\n    let granule = accMeta.cumulativeGranule;\r\n    \r\n    for (const chunk of chunks) {\r\n        // Disassemble chunk (auto-detects format)\r\n        const stream = disassembleOpusFile(chunk);\r\n        \r\n        // Assemble into data pages only (no headers)\r\n        const { data: chunkData, pageCount, finalGranule } = assembleOgg(stream, {\r\n            serialNumber: accMeta.serialNumber,\r\n            startingSequence: pageSequence,\r\n            startingGranule: granule,\r\n            includeHeaders: false,\r\n        });\r\n        \r\n        dataPages.push(chunkData);\r\n        \r\n        // Update state\r\n        granule = finalGranule;\r\n        pageSequence += pageCount;\r\n    }\r\n    \r\n    // Combine accumulator + new data\r\n    const totalSize = acc.length + dataPages.reduce((sum, p) => sum + p.length, 0);\r\n    const result = new Uint8Array(totalSize);\r\n    result.set(acc, 0);\r\n    \r\n    let offset = acc.length;\r\n    for (const page of dataPages) {\r\n        result.set(page, offset);\r\n        offset += page.length;\r\n    }\r\n    \r\n    return {\r\n        result,\r\n        meta: {\r\n            serialNumber: accMeta.serialNumber,\r\n            lastPageSequence: pageSequence - 1,\r\n            cumulativeGranule: granule,\r\n            totalSize: result.length,\r\n        }\r\n    };\r\n};","const exports: {\r\n    isDebug: boolean;\r\n    customLogger: ((...args: any[]) => void) | null;\r\n    debugLog: (...args: any[]) => void;\r\n} = {\r\n    isDebug: false,\r\n    customLogger: null,\r\n    debugLog: (...args: any[]) => {\r\n        if (!exports.isDebug) return;\r\n        if (exports.customLogger) {\r\n            exports.customLogger(...args);\r\n        } else {\r\n            console.debug(...args);\r\n        }\r\n    }\r\n}\r\n\r\nexport default exports;","import { OggPage } from \"./oggTypes\";\r\n\r\n/**\r\n * Scan for first \"OggS\" magic bytes in data\r\n * @param data \r\n * @returns position of first OggS or -1 if not found\r\n */\r\nexport const findOggStart = (data: Uint8Array): number => {\r\n    for (let i = 0; i <= data.length - 4; i++) {\r\n        if (data[i] === 0x4f && data[i + 1] === 0x67 &&\r\n            data[i + 2] === 0x67 && data[i + 3] === 0x53) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1; // Not found\r\n};\r\n\r\n\r\nexport const parseOggPage = (data: Uint8Array, offset: number): OggPage | null => {\r\n    if (offset + 27 > data.length) return null;\r\n\r\n    // Check for \"OggS\" magic\r\n    if (\r\n        data[offset] !== 0x4f ||\r\n        data[offset + 1] !== 0x67 ||\r\n        data[offset + 2] !== 0x67 ||\r\n        data[offset + 3] !== 0x53\r\n    ) {\r\n        return null;\r\n    }\r\n\r\n    const view = new DataView(data.buffer, data.byteOffset + offset);\r\n\r\n    const version = data[offset + 4];\r\n    const headerType = data[offset + 5];\r\n    const granulePosition = view.getBigInt64(6, true);\r\n    const serialNumber = view.getUint32(14, true);\r\n    const pageSequence = view.getUint32(18, true);\r\n    const checksum = view.getUint32(22, true);\r\n    const segments = data[offset + 26];\r\n\r\n    let bodySize = 0;\r\n    for (let i = 0; i < segments; i++) {\r\n        bodySize += data[offset + 27 + i];\r\n    }\r\n\r\n    const pageSize = 27 + segments + bodySize;\r\n\r\n    return {\r\n        version,\r\n        headerType,\r\n        granulePosition,\r\n        serialNumber,\r\n        pageSequence,\r\n        checksum,\r\n        segments,\r\n        bodySize,\r\n        pageSize,\r\n        offset,\r\n    };\r\n};","import { OpusFrame, OpusStream } from \"../types/opus\";\r\nimport { findOggStart, parseOggPage } from \"./oggParsing\";\r\n\r\nexport const disassembleOgg = (data: Uint8Array): OpusStream => {\r\n    const oggStart = findOggStart(data);\r\n    if (oggStart === -1) {\r\n        throw new Error('No Ogg data found');\r\n    }\r\n\r\n    const frames: OpusFrame[] = [];\r\n    let offset = oggStart;\r\n    let pageCount = 0;\r\n    let serialNumber: number | undefined;\r\n    let channels = 2;\r\n    let preskip = 312;\r\n    let sampleRate = 48000;\r\n    let lastGranule = BigInt(0);\r\n\r\n    while (offset < data.length) {\r\n        const page = parseOggPage(data, offset);\r\n        if (!page) break;\r\n\r\n        if (pageCount === 0) {\r\n            // Parse OpusHead for metadata\r\n            serialNumber = page.serialNumber;\r\n            const bodyOffset = 27 + page.segments;\r\n            channels = data[offset + bodyOffset + 9];\r\n            const view = new DataView(data.buffer, data.byteOffset + offset + bodyOffset);\r\n            preskip = view.getUint16(10, true);\r\n            sampleRate = view.getUint32(12, true);\r\n        } else if (pageCount === 1) {\r\n            // Skip OpusTags\r\n        } else {\r\n            // Data page - extract frame(s)\r\n            const bodyOffset = 27 + page.segments;\r\n            const bodyEnd = bodyOffset + page.bodySize;\r\n            \r\n            // Calculate samples for this page\r\n            const currentGranule = page.granulePosition;\r\n            const samples = Number(currentGranule - lastGranule);\r\n            \r\n            // For simplicity, treat entire page body as one frame\r\n            // (In reality, pages can contain multiple frames with lacing)\r\n            frames.push({\r\n                data: data.slice(offset + bodyOffset, offset + bodyEnd),\r\n                samples: samples,\r\n            });\r\n            \r\n            lastGranule = currentGranule;\r\n        }\r\n\r\n        offset += page.pageSize;\r\n        pageCount++;\r\n    }\r\n\r\n    return {\r\n        frames,\r\n        serialNumber,\r\n        channels,\r\n        preskip,\r\n        sampleRate,\r\n    };\r\n};","/**\r\n * Known Matroska/WebM element IDs\r\n */\r\nexport const EBML_IDS = {\r\n    EBML: 0x1A45DFA3,\r\n    Segment: 0x18538067,\r\n    Info: 0x1549A966,\r\n    Tracks: 0x1654AE6B,\r\n    Cluster: 0x1F43B675,\r\n    Timecode: 0xE7,\r\n    SimpleBlock: 0xA3,\r\n    BlockGroup: 0xA0,\r\n    Block: 0xA1,\r\n    TrackEntry: 0xAE,\r\n    TrackNumber: 0xD7,\r\n    TrackType: 0x83,\r\n    CodecID: 0x86,\r\n};","import { WebMFrame } from \"./webM\";\r\n\r\n/**\r\n * Read EBML variable-length integer (VINT)\r\n * First byte encodes both the length and part of the value\r\n */\r\nexport const readVINT = (data: Uint8Array, offset: number): { value: number, size: number } => {\r\n    const firstByte = data[offset];\r\n\r\n    // Find the length by counting leading zero bits\r\n    let mask = 0x80;\r\n    let size = 1;\r\n    while (size <= 8 && !(firstByte & mask)) {\r\n        mask >>= 1;\r\n        size++;\r\n    }\r\n\r\n    if (size > 8) {\r\n        throw new Error('Invalid VINT');\r\n    }\r\n\r\n    // Read the value (removing the length marker bit)\r\n    let value = firstByte & (mask - 1);\r\n    for (let i = 1; i < size; i++) {\r\n        value = (value << 8) | data[offset + i];\r\n    }\r\n\r\n    return { value, size };\r\n};\r\n\r\n/**\r\n * Read EBML element size\r\n */\r\nexport const readElementSize = (data: Uint8Array, offset: number): { size: number; dataSize: number } => {\r\n    const { value, size } = readVINT(data, offset);\r\n    return { size, dataSize: value };\r\n};\r\n\r\n/**\r\n * Parse a SimpleBlock or Block element\r\n */\r\nexport const parseBlock = (data: Uint8Array, clusterTimecode: number): WebMFrame => {\r\n    let offset = 0;\r\n\r\n    // Read track number (VINT)\r\n    const { value: trackNumber, size: trackSize } = readVINT(data, offset);\r\n    offset += trackSize;\r\n\r\n    // Read timecode (signed 16-bit integer, relative to cluster)\r\n    const timecodeRelative = (data[offset] << 8) | data[offset + 1];\r\n    const timecode = clusterTimecode + (timecodeRelative << 16 >> 16); // sign extend\r\n    offset += 2;\r\n\r\n    // Read flags (1 byte) - we can ignore for simple extraction\r\n    const flags = data[offset];\r\n    offset += 1;\r\n\r\n    // Rest is the frame data\r\n    const frameData = data.slice(offset);\r\n\r\n    return {\r\n        data: frameData,\r\n        timestamp: timecode,\r\n        trackNumber,\r\n    };\r\n};\r\n","import { OpusFrame, OpusStream } from \"../types/opus\";\r\nimport { WebMFrame } from \"./webM\";\r\nimport { EBML_IDS } from \"./matroskaTypes\";\r\nimport { parseBlock, readElementSize, readVINT } from \"./webmParse\";\r\n\r\nexport const disassembleWebM = (data: Uint8Array): OpusStream => {\r\n    const webmFrames = extractWebMFrames(data);\r\n\r\n    // Extract codec info from WebM (simplified - assume defaults)\r\n    const channels = 2;\r\n    const preskip = 312;\r\n    const sampleRate = 48000;\r\n    const samplesPerFrame = 960; // 20ms at 48kHz\r\n\r\n    const frames: OpusFrame[] = webmFrames.map(frame => ({\r\n        data: frame.data,\r\n        samples: samplesPerFrame, // WebM doesn't store this, assume 20ms frames\r\n    }));\r\n\r\n    return {\r\n        frames,\r\n        channels,\r\n        preskip,\r\n        sampleRate,\r\n    };\r\n};\r\n\r\n/**\r\n * Extract Opus frames from a WebM/Matroska file\r\n */\r\nexport const extractWebMFrames = (data: Uint8Array): WebMFrame[] => {\r\n    const frames: WebMFrame[] = [];\r\n    let offset = 0;\r\n    let clusterTimecode = 0;\r\n\r\n    // Find codec info first\r\n    let opusTrackNumber = -1;\r\n\r\n    while (offset < data.length) {\r\n        if (offset + 8 > data.length) break;\r\n\r\n        // Read element ID\r\n        const { value: elementId, size: idSize } = readVINT(data, offset);\r\n        offset += idSize;\r\n\r\n        // Read element size\r\n        const { size: sizeBytes, dataSize } = readElementSize(data, offset);\r\n        offset += sizeBytes;\r\n\r\n        if (offset + dataSize > data.length) break;\r\n\r\n        // Handle different element types\r\n        switch (elementId) {\r\n            case EBML_IDS.TrackEntry: {\r\n                // Parse track to find Opus codec\r\n                let trackOffset = offset;\r\n                let trackNum = -1;\r\n                let codecId = '';\r\n\r\n                while (trackOffset < offset + dataSize) {\r\n                    const { value: subId, size: subIdSize } = readVINT(data, trackOffset);\r\n                    trackOffset += subIdSize;\r\n                    const { size: subSizeBytes, dataSize: subDataSize } = readElementSize(data, trackOffset);\r\n                    trackOffset += subSizeBytes;\r\n\r\n                    if (subId === EBML_IDS.TrackNumber) {\r\n                        trackNum = data[trackOffset]; // Usually just 1 byte\r\n                    } else if (subId === EBML_IDS.CodecID) {\r\n                        codecId = new TextDecoder().decode(data.slice(trackOffset, trackOffset + subDataSize));\r\n                    }\r\n\r\n                    trackOffset += subDataSize;\r\n                }\r\n\r\n                if (codecId === 'A_OPUS' && trackNum !== -1) {\r\n                    opusTrackNumber = trackNum;\r\n                }\r\n                break;\r\n            }\r\n\r\n            case EBML_IDS.Cluster: {\r\n                // Parse cluster to extract blocks\r\n                let clusterOffset = offset;\r\n                clusterTimecode = 0;\r\n\r\n                while (clusterOffset < offset + dataSize) {\r\n                    const { value: subId, size: subIdSize } = readVINT(data, clusterOffset);\r\n                    clusterOffset += subIdSize;\r\n                    const { size: subSizeBytes, dataSize: subDataSize } = readElementSize(data, clusterOffset);\r\n                    clusterOffset += subSizeBytes;\r\n\r\n                    if (subId === EBML_IDS.Timecode) {\r\n                        // Cluster timecode (unsigned integer)\r\n                        clusterTimecode = 0;\r\n                        for (let i = 0; i < subDataSize; i++) {\r\n                            clusterTimecode = (clusterTimecode << 8) | data[clusterOffset + i];\r\n                        }\r\n                    } else if (subId === EBML_IDS.SimpleBlock) {\r\n                        const blockData = data.slice(clusterOffset, clusterOffset + subDataSize);\r\n                        const frame = parseBlock(blockData, clusterTimecode);\r\n\r\n                        // Only include frames from Opus track\r\n                        if (opusTrackNumber === -1 || frame.trackNumber === opusTrackNumber) {\r\n                            frames.push(frame);\r\n                        }\r\n                    } else if (subId === EBML_IDS.BlockGroup) {\r\n                        // BlockGroup contains Block element\r\n                        let bgOffset = clusterOffset;\r\n                        while (bgOffset < clusterOffset + subDataSize) {\r\n                            const { value: bgId, size: bgIdSize } = readVINT(data, bgOffset);\r\n                            bgOffset += bgIdSize;\r\n                            const { size: bgSizeBytes, dataSize: bgDataSize } = readElementSize(data, bgOffset);\r\n                            bgOffset += bgSizeBytes;\r\n\r\n                            if (bgId === EBML_IDS.Block) {\r\n                                const blockData = data.slice(bgOffset, bgOffset + bgDataSize);\r\n                                const frame = parseBlock(blockData, clusterTimecode);\r\n\r\n                                if (opusTrackNumber === -1 || frame.trackNumber === opusTrackNumber) {\r\n                                    frames.push(frame);\r\n                                }\r\n                            }\r\n\r\n                            bgOffset += bgDataSize;\r\n                        }\r\n                    }\r\n\r\n                    clusterOffset += subDataSize;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        offset += dataSize;\r\n    }\r\n\r\n    return frames;\r\n};","import { findOggStart } from \"../ogg/oggParsing\";\r\nimport { readVINT } from \"../webm/webmParse\";\r\nimport { AudioFormat } from \"./audioTypes\";\r\n\r\nexport const detectFormat = (data: Uint8Array): AudioFormat => {\r\n    // Check for Ogg\r\n    const oggStart = findOggStart(data);\r\n    if (oggStart !== -1) {\r\n        return AudioFormat.OGG_OPUS;\r\n    }\r\n    \r\n    // Check for WebM/Matroska EBML header\r\n    if (data.length >= 4) {\r\n        const { value: id } = readVINT(data, 0);\r\n        if (id === 0x1A45DFA3) { // EBML\r\n            return AudioFormat.WEBM;\r\n        }\r\n    }\r\n    \r\n    return AudioFormat.UNKNOWN;\r\n};","import { disassembleOgg } from \"../ogg/oggDisassemble\";\r\nimport { OpusStream } from \"../types/opus\";\r\nimport { disassembleWebM } from \"../webm/webmDisassemble\";\r\nimport { AudioFormat } from \"./audioTypes\";\r\nimport { detectFormat } from \"./formatDetection\";\r\n\r\n/**\r\n * Format-agnostic disassembly: detects format and extracts Opus frames\r\n */\r\nexport const disassembleOpusFile = (data: Uint8Array): OpusStream => {\r\n    const format = detectFormat(data);\r\n    \r\n    switch (format) {\r\n        case AudioFormat.OGG_OPUS:\r\n            return disassembleOgg(data);\r\n        case AudioFormat.WEBM:\r\n            return disassembleWebM(data);\r\n        case AudioFormat.UNKNOWN:\r\n            throw new Error('Unknown audio format (not Ogg Opus or WebM)');\r\n    }\r\n};","// CRC32 lookup table\r\nconst makeCRCTable = (): Uint32Array => {\r\n    const table = new Uint32Array(256);\r\n    for (let i = 0; i < 256; i++) {\r\n        let c = i << 24;\r\n        for (let j = 0; j < 8; j++) {\r\n            c = c & 0x80000000 ? (c << 1) ^ 0x04c11db7 : c << 1;\r\n        }\r\n        table[i] = c >>> 0;\r\n    }\r\n    return table;\r\n};\r\n\r\nconst crcTable: Uint32Array = makeCRCTable();\r\n\r\nexport const calculateCRC = (data: Uint8Array): number => {\r\n    let crc = 0;\r\n    for (let i = 0; i < data.length; i++) {\r\n        crc = ((crc << 8) ^ crcTable[((crc >>> 24) ^ data[i]) & 0xff]) >>> 0;\r\n    }\r\n    return crc;\r\n};","import { calculateCRC } from \"./oggCrc\";\r\n\r\n/**\r\n * Create a minimal OpusTags page with length/duration info omitted\r\n * @param serialNumber stream serial number\r\n * @param pageSequence page sequence number\r\n * @returns Uint8Array representing the OpusTags page\r\n */\r\nexport const createMinimalOpusTagsPage = (\r\n    serialNumber: number,\r\n    pageSequence: number,\r\n): Uint8Array => {\r\n    const vendorString = \"ogg-opus-concat\";\r\n    const vendorLength = vendorString.length;\r\n\r\n    // OpusTags structure:\r\n    // - \"OpusTags\" magic signature (8 bytes)\r\n    // - vendor string length (4 bytes, little-endian)\r\n    // - vendor string\r\n    // - user comment list length (4 bytes, little-endian) = 0\r\n    const bodySize = 8 + 4 + vendorLength + 4;\r\n    const body = new Uint8Array(bodySize);\r\n    let offset = 0;\r\n\r\n    // Magic signature\r\n    body.set(new TextEncoder().encode(\"OpusTags\"), offset);\r\n    offset += 8;\r\n\r\n    // Vendor string length (little-endian)\r\n    body[offset++] = vendorLength & 0xff;\r\n    body[offset++] = (vendorLength >> 8) & 0xff;\r\n    body[offset++] = (vendorLength >> 16) & 0xff;\r\n    body[offset++] = (vendorLength >> 24) & 0xff;\r\n\r\n    // Vendor string\r\n    body.set(new TextEncoder().encode(vendorString), offset);\r\n    offset += vendorLength;\r\n\r\n    // User comment list length = 0\r\n    body[offset++] = 0;\r\n    body[offset++] = 0;\r\n    body[offset++] = 0;\r\n    body[offset++] = 0;\r\n\r\n    // Create Ogg page with proper segment table\r\n    const segments = Math.ceil(bodySize / 255);\r\n    const segmentTable = new Uint8Array(segments);\r\n    for (let i = 0; i < segments - 1; i++) {\r\n        segmentTable[i] = 255;\r\n    }\r\n    segmentTable[segments - 1] = bodySize % 255 || 255;\r\n\r\n    const pageSize = 27 + segments + bodySize;\r\n    const page = new Uint8Array(pageSize);\r\n    const view = new DataView(page.buffer);\r\n\r\n    // OggS magic\r\n    page[0] = 0x4f;\r\n    page[1] = 0x67;\r\n    page[2] = 0x67;\r\n    page[3] = 0x53;\r\n\r\n    // Version\r\n    page[4] = 0;\r\n\r\n    // Header type (continuation of logical bitstream)\r\n    page[5] = 0x00;\r\n\r\n    // Granule position (0 for header)\r\n    view.setBigInt64(6, BigInt(0), true);\r\n\r\n    // Serial number\r\n    view.setUint32(14, serialNumber, true);\r\n\r\n    // Page sequence\r\n    view.setUint32(18, pageSequence, true);\r\n\r\n    // Checksum (will be calculated below)\r\n    view.setUint32(22, 0, true);\r\n\r\n    // Segments\r\n    page[26] = segments;\r\n\r\n    // Segment table\r\n    page.set(segmentTable, 27);\r\n\r\n    // Body\r\n    page.set(body, 27 + segments);\r\n\r\n    // Calculate and set checksum\r\n    const crc = calculateCRC(page);\r\n    view.setUint32(22, crc, true);\r\n\r\n    return page;\r\n};\r\n\r\n/**\r\n * Create an OpusHead identification header page\r\n */\r\nexport const createOpusHeadPage = (\r\n    serialNumber: number,\r\n    channels: number = 2,\r\n    preskip: number = 312, // Standard Opus pre-skip\r\n    sampleRate: number = 48000,\r\n): Uint8Array => {\r\n    // OpusHead structure (19 bytes):\r\n    // - \"OpusHead\" magic (8 bytes)\r\n    // - version (1 byte) = 1\r\n    // - channel count (1 byte)\r\n    // - pre-skip (2 bytes, little-endian)\r\n    // - input sample rate (4 bytes, little-endian)\r\n    // - output gain (2 bytes, little-endian) = 0\r\n    // - channel mapping family (1 byte) = 0\r\n    \r\n    const body = new Uint8Array(19);\r\n    const view = new DataView(body.buffer);\r\n    let offset = 0;\r\n    \r\n    // Magic signature\r\n    body.set(new TextEncoder().encode('OpusHead'), offset);\r\n    offset += 8;\r\n    \r\n    // Version\r\n    body[offset++] = 1;\r\n    \r\n    // Channel count\r\n    body[offset++] = channels;\r\n    \r\n    // Pre-skip\r\n    view.setUint16(offset, preskip, true);\r\n    offset += 2;\r\n    \r\n    // Input sample rate\r\n    view.setUint32(offset, sampleRate, true);\r\n    offset += 4;\r\n    \r\n    // Output gain\r\n    view.setInt16(offset, 0, true);\r\n    offset += 2;\r\n    \r\n    // Channel mapping family\r\n    body[offset++] = 0;\r\n    \r\n    // Create Ogg page\r\n    return createOggPage({\r\n        headerType: 0x02, // BOS (Beginning of Stream)\r\n        granulePosition: BigInt(0),\r\n        serialNumber,\r\n        pageSequence: 0,\r\n        body,\r\n    });\r\n};\r\n\r\n/**\r\n * Create an Ogg page from body data\r\n */\r\nexport const createOggPage = (options: {\r\n    headerType: number;\r\n    granulePosition: bigint;\r\n    serialNumber: number;\r\n    pageSequence: number;\r\n    body: Uint8Array;\r\n}): Uint8Array => {\r\n    const { headerType, granulePosition, serialNumber, pageSequence, body } = options;\r\n    \r\n    // Calculate segment table\r\n    const bodySize = body.length;\r\n    const fullSegments = Math.floor(bodySize / 255);\r\n    const lastSegmentSize = bodySize % 255;\r\n    const segments = fullSegments + (lastSegmentSize > 0 ? 1 : 0);\r\n    \r\n    const segmentTable = new Uint8Array(segments);\r\n    for (let i = 0; i < fullSegments; i++) {\r\n        segmentTable[i] = 255;\r\n    }\r\n    if (lastSegmentSize > 0) {\r\n        segmentTable[fullSegments] = lastSegmentSize;\r\n    }\r\n    \r\n    // Create page\r\n    const pageSize = 27 + segments + bodySize;\r\n    const page = new Uint8Array(pageSize);\r\n    const view = new DataView(page.buffer);\r\n    \r\n    // OggS magic\r\n    page[0] = 0x4f; // 'O'\r\n    page[1] = 0x67; // 'g'\r\n    page[2] = 0x67; // 'g'\r\n    page[3] = 0x53; // 'S'\r\n    \r\n    // Version\r\n    page[4] = 0;\r\n    \r\n    // Header type\r\n    page[5] = headerType;\r\n    \r\n    // Granule position\r\n    view.setBigInt64(6, granulePosition, true);\r\n    \r\n    // Serial number\r\n    view.setUint32(14, serialNumber, true);\r\n    \r\n    // Page sequence\r\n    view.setUint32(18, pageSequence, true);\r\n    \r\n    // Checksum (calculate later)\r\n    view.setUint32(22, 0, true);\r\n    \r\n    // Segment count\r\n    page[26] = segments;\r\n    \r\n    // Segment table\r\n    page.set(segmentTable, 27);\r\n    \r\n    // Body\r\n    page.set(body, 27 + segments);\r\n    \r\n    // Calculate and set checksum\r\n    const crc = calculateCRC(page);\r\n    view.setUint32(22, crc, true);\r\n    \r\n    return page;\r\n};\r\n\r\n/**\r\n * Calculate granule position for an Opus packet\r\n * Opus uses 48kHz sample rate, typical frame is 20ms = 960 samples\r\n */\r\nconst calculateOpusGranule = (packetIndex: number, samplesPerPacket: number = 960): bigint => {\r\n    return BigInt((packetIndex + 1) * samplesPerPacket);\r\n};\r\n\r\n/**\r\n * Wrap raw Opus packets into a complete Ogg Opus file\r\n */\r\nexport const wrapOpusPacketsInOgg = (\r\n    packets: Uint8Array[],\r\n    options?: {\r\n        channels?: number;\r\n        preskip?: number;\r\n        sampleRate?: number;\r\n        serialNumber?: number;\r\n    }\r\n): Uint8Array => {\r\n    const channels = options?.channels ?? 2;\r\n    const preskip = options?.preskip ?? 312;\r\n    const sampleRate = options?.sampleRate ?? 48000;\r\n    const serialNumber = options?.serialNumber ?? Math.floor(Math.random() * 0xFFFFFFFF);\r\n    \r\n    const pages: Uint8Array[] = [];\r\n    let pageSequence = 0;\r\n    \r\n    // Page 0: OpusHead\r\n    const opusHead = createOpusHeadPage(serialNumber, channels, preskip, sampleRate);\r\n    pages.push(opusHead);\r\n    pageSequence++;\r\n    \r\n    // Page 1: OpusTags (minimal)\r\n    const opusTags = createMinimalOpusTagsPage(serialNumber, pageSequence);\r\n    pages.push(opusTags);\r\n    pageSequence++;\r\n    \r\n    // Data pages: wrap packets\r\n    // Group multiple packets per page for efficiency (max ~4KB per page)\r\n    const MAX_PAGE_SIZE = 4000;\r\n    let currentPagePackets: Uint8Array[] = [];\r\n    let currentPageSize = 0;\r\n    \r\n    for (let i = 0; i < packets.length; i++) {\r\n        const packet = packets[i];\r\n        \r\n        // Check if adding this packet would exceed page size\r\n        if (currentPageSize + packet.length > MAX_PAGE_SIZE && currentPagePackets.length > 0) {\r\n            // Flush current page\r\n            const pageBody = new Uint8Array(currentPageSize);\r\n            let offset = 0;\r\n            for (const p of currentPagePackets) {\r\n                pageBody.set(p, offset);\r\n                offset += p.length;\r\n            }\r\n            \r\n            const granule = calculateOpusGranule(i - 1); // Granule of last packet in page\r\n            const page = createOggPage({\r\n                headerType: 0x00,\r\n                granulePosition: granule,\r\n                serialNumber,\r\n                pageSequence,\r\n                body: pageBody,\r\n            });\r\n            \r\n            pages.push(page);\r\n            pageSequence++;\r\n            \r\n            // Reset for next page\r\n            currentPagePackets = [];\r\n            currentPageSize = 0;\r\n        }\r\n        \r\n        currentPagePackets.push(packet);\r\n        currentPageSize += packet.length;\r\n    }\r\n    \r\n    // Flush remaining packets\r\n    if (currentPagePackets.length > 0) {\r\n        const pageBody = new Uint8Array(currentPageSize);\r\n        let offset = 0;\r\n        for (const p of currentPagePackets) {\r\n            pageBody.set(p, offset);\r\n            offset += p.length;\r\n        }\r\n        \r\n        const granule = calculateOpusGranule(packets.length - 1);\r\n        const page = createOggPage({\r\n            headerType: 0x04, // EOS (End of Stream) on last page\r\n            granulePosition: granule,\r\n            serialNumber,\r\n            pageSequence,\r\n            body: pageBody,\r\n        });\r\n        \r\n        pages.push(page);\r\n    }\r\n    \r\n    // Combine all pages\r\n    const totalSize = pages.reduce((sum, page) => sum + page.length, 0);\r\n    const result = new Uint8Array(totalSize);\r\n    let resultOffset = 0;\r\n    for (const page of pages) {\r\n        result.set(page, resultOffset);\r\n        resultOffset += page.length;\r\n    }\r\n    \r\n    return result;\r\n};","import { OpusStream } from \"../types/opus\";\r\nimport { createMinimalOpusTagsPage, createOggPage, createOpusHeadPage } from \"./oggWrite\";\r\n\r\n/**\r\n * Assemble frames into appendable Ogg Opus file\r\n * @param stream \r\n * @param options \r\n * @returns \r\n */\r\nexport const assembleOgg = (stream: OpusStream, options?: {\r\n    serialNumber?: number;\r\n    startingSequence?: number;\r\n    startingGranule?: bigint;\r\n    includeHeaders?: boolean;\r\n}): { data: Uint8Array; pageCount: number; finalGranule: bigint } => {\r\n    const serialNumber = options?.serialNumber ?? stream.serialNumber ?? Math.floor(Math.random() * 0xFFFFFFFF);\r\n    const includeHeaders = options?.includeHeaders ?? true;\r\n    let pageSequence = options?.startingSequence ?? 0;\r\n    let granule = options?.startingGranule ?? BigInt(0);\r\n\r\n    const pages: Uint8Array[] = [];\r\n    let pageCount = 0;\r\n\r\n    // Add headers if requested\r\n    if (includeHeaders) {\r\n        pages.push(createOpusHeadPage(serialNumber, stream.channels, stream.preskip, stream.sampleRate));\r\n        pageSequence++;\r\n        pageCount++;\r\n\r\n        pages.push(createMinimalOpusTagsPage(serialNumber, pageSequence));\r\n        pageSequence++;\r\n        pageCount++;\r\n    }\r\n\r\n    // Add data pages\r\n    const MAX_PAGE_SIZE = 4000;\r\n    let currentPageData: Uint8Array[] = [];\r\n    let currentPageSize = 0;\r\n    let currentPageSamples = 0;\r\n\r\n    for (const frame of stream.frames) {\r\n        // Flush page if needed\r\n        if (currentPageSize + frame.data.length > MAX_PAGE_SIZE && currentPageData.length > 0) {\r\n            const pageBody = new Uint8Array(currentPageSize);\r\n            let offset = 0;\r\n            for (const d of currentPageData) {\r\n                pageBody.set(d, offset);\r\n                offset += d.length;\r\n            }\r\n\r\n            granule += BigInt(currentPageSamples);\r\n\r\n            const page = createOggPage({\r\n                headerType: 0x00,\r\n                granulePosition: granule,\r\n                serialNumber,\r\n                pageSequence,\r\n                body: pageBody,\r\n            });\r\n\r\n            pages.push(page);\r\n            pageSequence++;\r\n            pageCount++;\r\n\r\n            currentPageData = [];\r\n            currentPageSize = 0;\r\n            currentPageSamples = 0;\r\n        }\r\n\r\n        currentPageData.push(frame.data);\r\n        currentPageSize += frame.data.length;\r\n        currentPageSamples += frame.samples;\r\n    }\r\n\r\n    // Flush remaining\r\n    if (currentPageData.length > 0) {\r\n        const pageBody = new Uint8Array(currentPageSize);\r\n        let offset = 0;\r\n        for (const d of currentPageData) {\r\n            pageBody.set(d, offset);\r\n            offset += d.length;\r\n        }\r\n\r\n        granule += BigInt(currentPageSamples);\r\n\r\n        const page = createOggPage({\r\n            headerType: 0x00,\r\n            granulePosition: granule,\r\n            serialNumber,\r\n            pageSequence,\r\n            body: pageBody,\r\n        });\r\n\r\n        pages.push(page);\r\n        pageCount++;\r\n    }\r\n\r\n    // Combine pages\r\n    const totalSize = pages.reduce((sum, p) => sum + p.length, 0);\r\n    const data = new Uint8Array(totalSize);\r\n    let resultOffset = 0;\r\n    for (const page of pages) {\r\n        data.set(page, resultOffset);\r\n        resultOffset += page.length;\r\n    }\r\n\r\n    return { data, pageCount, finalGranule: granule };\r\n};"],"mappings":"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","names":["index_exports","__export","addToAcc","concatenateOpusFiles","prepareForConcat","setCustomDebugLogger","setDebug","__toCommonJS","exports","args","debugger_default","findOggStart","data","i","parseOggPage","offset","view","version","headerType","granulePosition","serialNumber","pageSequence","checksum","segments","bodySize","pageSize","disassembleOgg","data","oggStart","findOggStart","frames","offset","pageCount","serialNumber","channels","preskip","sampleRate","lastGranule","page","parseOggPage","bodyOffset","view","bodyEnd","currentGranule","samples","EBML_IDS","readVINT","data","offset","firstByte","mask","size","value","i","readElementSize","parseBlock","clusterTimecode","trackNumber","trackSize","timecodeRelative","timecode","flags","disassembleWebM","data","webmFrames","extractWebMFrames","channels","preskip","sampleRate","samplesPerFrame","frame","frames","offset","clusterTimecode","opusTrackNumber","elementId","idSize","readVINT","sizeBytes","dataSize","readElementSize","EBML_IDS","trackOffset","trackNum","codecId","subId","subIdSize","subSizeBytes","subDataSize","clusterOffset","i","blockData","parseBlock","bgOffset","bgId","bgIdSize","bgSizeBytes","bgDataSize","detectFormat","data","findOggStart","id","readVINT","disassembleOpusFile","data","detectFormat","disassembleOgg","disassembleWebM","makeCRCTable","table","i","c","j","crcTable","calculateCRC","data","crc","createMinimalOpusTagsPage","serialNumber","pageSequence","vendorString","vendorLength","bodySize","body","offset","segments","segmentTable","i","pageSize","page","view","crc","calculateCRC","createOpusHeadPage","channels","preskip","sampleRate","createOggPage","options","headerType","granulePosition","fullSegments","lastSegmentSize","assembleOgg","stream","options","serialNumber","includeHeaders","pageSequence","granule","pages","pageCount","createOpusHeadPage","createMinimalOpusTagsPage","MAX_PAGE_SIZE","currentPageData","currentPageSize","currentPageSamples","frame","pageBody","offset","d","page","createOggPage","totalSize","sum","p","data","resultOffset","setDebug","enabled","debugger_default","setCustomDebugLogger","logger","concatenateOpusFiles","chunks","prepared","meta","prepareForConcat","result","addToAcc","data","stream","disassembleOpusFile","assembleOgg","offset","findOggStart","lastPageSequence","maxGranule","serialNumber","page","parseOggPage","acc","accMeta","dataPages","pageSequence","granule","chunk","chunkData","pageCount","finalGranule","totalSize","sum","p"]}
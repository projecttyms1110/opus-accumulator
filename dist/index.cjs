"use strict";var B=Object.defineProperty;var _=Object.getOwnPropertyDescriptor;var V=Object.getOwnPropertyNames;var K=Object.prototype.hasOwnProperty;var X=(e,t)=>{for(var r in t)B(e,r,{get:t[r],enumerable:!0})},Z=(e,t,r,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of V(t))!K.call(e,n)&&n!==r&&B(e,n,{get:()=>t[n],enumerable:!(s=_(t,n))||s.enumerable});return e};var j=e=>Z(B({},"__esModule",{value:!0}),e);var ne={};X(ne,{appendToAccumulator:()=>H,concatChunks:()=>re,prepareAccumulator:()=>R,setCustomDebugLogger:()=>te,setDebug:()=>ee});module.exports=j(ne);var k={isDebug:!1,customLogger:null,debugLog:(...e)=>{k.isDebug&&(k.customLogger?k.customLogger(...e):console.debug(...e))}},d=k;var A=e=>{for(let t=0;t<=e.length-4;t++)if(e[t]===79&&e[t+1]===103&&e[t+2]===103&&e[t+3]===83)return t;return-1},P=(e,t)=>{if(t+27>e.length||e[t]!==79||e[t+1]!==103||e[t+2]!==103||e[t+3]!==83)return null;let r=new DataView(e.buffer,e.byteOffset+t),s=e[t+4],n=e[t+5],i=r.getBigInt64(6,!0),a=r.getUint32(14,!0),u=r.getUint32(18,!0),c=r.getUint32(22,!0),o=e[t+26],l=0;for(let g=0;g<o;g++)l+=e[t+27+g];let m=27+o+l;return{version:s,headerType:n,granulePosition:i,serialNumber:a,pageSequence:u,checksum:c,segments:o,bodySize:l,pageSize:m,offset:t}};var q=e=>{let t=A(e);if(t===-1)throw new Error("No Ogg data found");t>0&&d.debugLog(`Skipping ${t} bytes of non-Ogg data at start`);let r=[],s=t,n=0,i,a=2,u=312,c=48e3,o=BigInt(0);for(;s<e.length;){let l=P(e,s);if(!l){d.debugLog(`Failed to parse Ogg page at offset ${s}`);break}if(n===0){i=l.serialNumber;let m=27+l.segments;a=e[s+m+9];let g=new DataView(e.buffer,e.byteOffset+s+m);u=g.getUint16(10,!0),c=g.getUint32(12,!0),d.debugLog(`OpusHead: channels=${a}, preskip=${u}, sampleRate=${c}, serial=${i}`)}else if(n===1)d.debugLog("Skipping OpusTags page");else{let m=27+l.segments,g=m+l.bodySize,p=l.granulePosition,f=Number(p-o);d.debugLog(`Data page ${n}: granule=${p}, samples=${f}, size=${l.bodySize}`),r.push({data:e.slice(s+m,s+g),samples:f}),o=p}s+=l.pageSize,n++}return d.debugLog(`Disassembled ${r.length} frames from Ogg, total granule: ${o}`),{frames:r,serialNumber:i,channels:a,preskip:u,sampleRate:c}};var S={EBML:440786851,Segment:408125543,Info:357149030,Tracks:374648427,Cluster:524531317,Timecode:231,SimpleBlock:163,BlockGroup:160,Block:161,TrackEntry:174,TrackNumber:215,TrackType:131,CodecID:134};var x=(e,t)=>{let r=e[t],s=128,n=1;for(;n<=8&&!(r&s);)s>>=1,n++;if(n>8)throw new Error("Invalid VINT");let i=r&s-1;for(let a=1;a<n;a++)i=i<<8|e[t+a];return{value:i,size:n}},z=(e,t)=>{let{value:r,size:s}=x(e,t);return{size:s,dataSize:r}},I=(e,t)=>{let r=0,{value:s,size:n}=x(e,r);r+=n;let i=e[r]<<8|e[r+1],a=t+(i<<16>>16);r+=2;let u=e[r];return r+=1,{data:e.slice(r),timestamp:a,trackNumber:s}};var{debugLog:N}=d,L=e=>{N("Extracting WebM frames");let t=J(e);N(`Extracted ${t.length} WebM frames`);let r=2,s=312,n=48e3,i=960,a=t.map(u=>({data:u.data,samples:i}));return N(`Converted to ${a.length} Opus frames`),N(`Returning Opus stream with channels=${r}, preskip=${s}, sampleRate=${n}`),{frames:a,channels:r,preskip:s,sampleRate:n}},J=e=>{let t=[],r=0,s=0,n=-1;for(;r<e.length&&!(r+8>e.length);){let{value:i,size:a}=x(e,r);r+=a;let{size:u,dataSize:c}=z(e,r);if(r+=u,r+c>e.length)break;switch(i){case S.TrackEntry:{let o=r,l=-1,m="";for(;o<r+c;){let{value:g,size:p}=x(e,o);o+=p;let{size:f,dataSize:b}=z(e,o);o+=f,g===S.TrackNumber?l=e[o]:g===S.CodecID&&(m=new TextDecoder().decode(e.slice(o,o+b))),o+=b}m==="A_OPUS"&&l!==-1&&(n=l);break}case S.Cluster:{let o=r;for(s=0;o<r+c;){let{value:l,size:m}=x(e,o);o+=m;let{size:g,dataSize:p}=z(e,o);if(o+=g,l===S.Timecode){s=0;for(let f=0;f<p;f++)s=s<<8|e[o+f]}else if(l===S.SimpleBlock){let f=e.slice(o,o+p),b=I(f,s);(n===-1||b.trackNumber===n)&&t.push(b)}else if(l===S.BlockGroup){let f=o;for(;f<o+p;){let{value:b,size:h}=x(e,f);f+=h;let{size:U,dataSize:O}=z(e,f);if(f+=U,b===S.Block){let $=e.slice(f,f+O),G=I($,s);(n===-1||G.trackNumber===n)&&t.push(G)}f+=O}}o+=p}break}}r+=c}return t};var T=(s=>(s[s.OGG_OPUS=0]="OGG_OPUS",s[s.WEBM=1]="WEBM",s[s.UNKNOWN=2]="UNKNOWN",s))(T||{});var C=e=>{if(A(e)!==-1)return 0;if(e.length>=4){let{value:r}=x(e,0);if(r===440786851)return 1}return 2};var v=e=>{let t=C(e);switch(d.debugLog(`Detected format: ${T[t]}`),t){case 0:return q(e);case 1:return L(e);case 2:throw new Error("Unknown audio format (not Ogg Opus or WebM)")}};var Q=()=>{let e=new Uint32Array(256);for(let t=0;t<256;t++){let r=t<<24;for(let s=0;s<8;s++)r=r&2147483648?r<<1^79764919:r<<1;e[t]=r>>>0}return e},Y=Q(),D=e=>{let t=0;for(let r=0;r<e.length;r++)t=(t<<8^Y[(t>>>24^e[r])&255])>>>0;return t};var M=(e,t)=>{let r="ogg-opus-concat",s=r.length,n=12+s+4,i=new Uint8Array(n),a=0;i.set(new TextEncoder().encode("OpusTags"),a),a+=8,i[a++]=s&255,i[a++]=s>>8&255,i[a++]=s>>16&255,i[a++]=s>>24&255,i.set(new TextEncoder().encode(r),a),a+=s,i[a++]=0,i[a++]=0,i[a++]=0,i[a++]=0;let u=Math.ceil(n/255),c=new Uint8Array(u);for(let p=0;p<u-1;p++)c[p]=255;c[u-1]=n%255||255;let o=27+u+n,l=new Uint8Array(o),m=new DataView(l.buffer);l[0]=79,l[1]=103,l[2]=103,l[3]=83,l[4]=0,l[5]=0,m.setBigInt64(6,BigInt(0),!0),m.setUint32(14,e,!0),m.setUint32(18,t,!0),m.setUint32(22,0,!0),l[26]=u,l.set(c,27),l.set(i,27+u);let g=D(l);return m.setUint32(22,g,!0),l},W=(e,t=2,r=312,s=48e3)=>{let n=new Uint8Array(19),i=new DataView(n.buffer),a=0;return n.set(new TextEncoder().encode("OpusHead"),a),a+=8,n[a++]=1,n[a++]=t,i.setUint16(a,r,!0),a+=2,i.setUint32(a,s,!0),a+=4,i.setInt16(a,0,!0),a+=2,n[a++]=0,F({headerType:2,granulePosition:BigInt(0),serialNumber:e,pageSequence:0,body:n})},F=e=>{let{headerType:t,granulePosition:r,serialNumber:s,pageSequence:n,body:i}=e,a=i.length,u=Math.floor(a/255),c=a%255,o=u+(c>0?1:0),l=new Uint8Array(o);for(let b=0;b<u;b++)l[b]=255;c>0&&(l[u]=c);let m=27+o+a,g=new Uint8Array(m),p=new DataView(g.buffer);g[0]=79,g[1]=103,g[2]=103,g[3]=83,g[4]=0,g[5]=t,p.setBigInt64(6,r,!0),p.setUint32(14,s,!0),p.setUint32(18,n,!0),p.setUint32(22,0,!0),g[26]=o,g.set(l,27),g.set(i,27+o);let f=D(g);return p.setUint32(22,f,!0),g};var{debugLog:w}=d,E=(e,t)=>{let r=t?.serialNumber??e.serialNumber??Math.floor(Math.random()*4294967295),s=t?.includeHeaders??!0,n=t?.startingSequence??0,i=t?.startingGranule??BigInt(0),a=[],u=0;s?(w(`Creating OpusHead: serial=${r}, channels=${e.channels}, preskip=${e.preskip}, sampleRate=${e.sampleRate}`),a.push(W(r,e.channels,e.preskip,e.sampleRate)),n++,u++,w(`Creating minimal OpusTags: sequence=${n}`),a.push(M(r,n)),n++,u++):w(`Assembling data pages only (no headers), starting at sequence=${n}, granule=${i}`);let c=4e3,o=[],l=0,m=0;for(let b of e.frames){if(l+b.data.length>c&&o.length>0){let h=new Uint8Array(l);w(`Flushing page: sequence=${n}, granule=${i}, size=${h.length}, packets=${o.length}`);let U=0;for(let $ of o)h.set($,U),U+=$.length;i+=BigInt(m);let O=F({headerType:0,granulePosition:i,serialNumber:r,pageSequence:n,body:h});a.push(O),n++,u++,o=[],l=0,m=0}o.push(b.data),l+=b.data.length,m+=b.samples}if(o.length>0){let b=new Uint8Array(l),h=0;for(let O of o)b.set(O,h),h+=O.length;i+=BigInt(m);let U=F({headerType:0,granulePosition:i,serialNumber:r,pageSequence:n,body:b});a.push(U),u++}let g=a.reduce((b,h)=>b+h.length,0),p=new Uint8Array(g),f=0;for(let b of a)p.set(b,f),f+=b.length;return w(`Assembled ${u} pages, final granule: ${i}, total size: ${p.length} bytes`),{data:p,pageCount:u,finalGranule:i}};var ee=e=>{d.isDebug=e},te=e=>{d.customLogger=e},{debugLog:y}=d,re=e=>{if(e.length===0)throw new Error("No chunks provided");y(`
=== Concatenating ${e.length} chunks ===`);let{result:t,meta:r}=R(e[0]);return y(`First chunk prepared: ${t.length} bytes, granule=${r.cumulativeGranule}`),e.length===1||({result:t}=H(t,e.slice(1),r),y(`Final result: ${t.length} bytes
`)),t},R=e=>{y(`
=== Preparing accumulator from ${e.length} byte file ===`);let t=v(e),{data:r}=E(t,{includeHeaders:!0}),n=A(r),i=0,a=BigInt(0),u=t.serialNumber??0;for(;n<r.length;){let c=P(r,n);if(!c)break;u===0&&(u=c.serialNumber),i=c.pageSequence,c.granulePosition>a&&(a=c.granulePosition),n+=c.pageSize}return y(`Prepared accumulator: serial=${u}, lastSeq=${i}, granule=${a}, size=${r.length}`),{result:r,meta:{serialNumber:u,lastPageSequence:i,cumulativeGranule:a,totalSize:r.length}}},H=(e,t,r)=>{y(`
=== Appending ${t.length} chunks to accumulator ===`),y(`Starting state: seq=${r.lastPageSequence}, granule=${r.cumulativeGranule}, size=${r.totalSize}`);let s=[],n=r.lastPageSequence+1,i=r.cumulativeGranule;for(let o=0;o<t.length;o++){let l=t[o];y(`
--- Processing chunk ${o+1}/${t.length} (${l.length} bytes) ---`);let m=v(l),{data:g,pageCount:p,finalGranule:f}=E(m,{serialNumber:r.serialNumber,startingSequence:n,startingGranule:i,includeHeaders:!1});s.push(g),i=f,n+=p,y(`Chunk assembled: ${p} pages, granule advanced to ${f}`)}let a=e.length+s.reduce((o,l)=>o+l.length,0),u=new Uint8Array(a);u.set(e,0);let c=e.length;for(let o of s)u.set(o,c),c+=o.length;return y(`
Final state: seq=${n-1}, granule=${i}, total size=${u.length}`),{result:u,meta:{serialNumber:r.serialNumber,lastPageSequence:n-1,cumulativeGranule:i,totalSize:u.length}}};0&&(module.exports={appendToAccumulator,concatChunks,prepareAccumulator,setCustomDebugLogger,setDebug});
//# sourceMappingURL=index.cjs.map
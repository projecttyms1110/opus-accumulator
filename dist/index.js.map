{"version":3,"sources":["../src/common/debugger.ts","../src/ogg/oggParsing.ts","../src/ogg/oggDisassemble.ts","../src/webm/EBMLTypes.ts","../src/webm/webmParse.ts","../src/opus/opusParsing.ts","../src/webm/webmDisassemble.ts","../src/common/audioTypes.ts","../src/common/formatDetection.ts","../src/common/disassemble.ts","../src/ogg/oggCrc.ts","../src/ogg/oggWrite.ts","../src/ogg/oggAssemble.ts","../src/index.ts"],"sourcesContent":["export type DebugCategory = 'parser' | 'disassembler' | 'assembler' | 'index';\r\n\r\nconst exported: {\r\n    isDebug: boolean;\r\n    customLogger: ((...args: any[]) => void) | null;\r\n    /** Empty set means all categories enabled */\r\n    enabledCategories: Set<DebugCategory>;\r\n    debugLog: (...args: any[]) => void;\r\n} = {\r\n    isDebug: false,\r\n    customLogger: null,\r\n    enabledCategories: new Set<DebugCategory>([]),\r\n    debugLog: (category: DebugCategory, ...args: any[]) => {\r\n        if (!exported.isDebug) return;\r\n\r\n        if (exported.enabledCategories.size && !exported.enabledCategories.has(category)) return;\r\n\r\n        if (exported.customLogger) {\r\n            exported.customLogger(category, ...args);\r\n        } else {\r\n            console.debug(`Category: ${category}`, ...args);\r\n        }\r\n    }\r\n}\r\n\r\nexport default exported;","import { OggPage } from \"./oggTypes\";\r\n\r\n/**\r\n * Scan for first \"OggS\" magic bytes in data\r\n * @param data \r\n * @returns position of first OggS or -1 if not found\r\n */\r\nexport const findOggStart = (data: Uint8Array): number => {\r\n    for (let i = 0; i <= data.length - 4; i++) {\r\n        if (data[i] === 0x4f && data[i + 1] === 0x67 &&\r\n            data[i + 2] === 0x67 && data[i + 3] === 0x53) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1; // Not found\r\n};\r\n\r\n\r\nexport const parseOggPage = (data: Uint8Array, offset: number): OggPage | null => {\r\n    if (offset + 27 > data.length) return null;\r\n\r\n    // Check for \"OggS\" magic\r\n    if (\r\n        data[offset] !== 0x4f ||\r\n        data[offset + 1] !== 0x67 ||\r\n        data[offset + 2] !== 0x67 ||\r\n        data[offset + 3] !== 0x53\r\n    ) {\r\n        return null;\r\n    }\r\n\r\n    const view = new DataView(data.buffer, data.byteOffset + offset);\r\n\r\n    const version = data[offset + 4];\r\n    const headerType = data[offset + 5];\r\n    const granulePosition = view.getBigInt64(6, true);\r\n    const serialNumber = view.getUint32(14, true);\r\n    const pageSequence = view.getUint32(18, true);\r\n    const checksum = view.getUint32(22, true);\r\n    const segments = data[offset + 26];\r\n\r\n    let bodySize = 0;\r\n    for (let i = 0; i < segments; i++) {\r\n        bodySize += data[offset + 27 + i];\r\n    }\r\n\r\n    const pageSize = 27 + segments + bodySize;\r\n\r\n    return {\r\n        version,\r\n        headerType,\r\n        granulePosition,\r\n        serialNumber,\r\n        pageSequence,\r\n        checksum,\r\n        segments,\r\n        bodySize,\r\n        pageSize,\r\n        offset,\r\n    };\r\n};","import { OpusFrame, OpusStream } from \"../types/opus\";\r\nimport { findOggStart, parseOggPage } from \"./oggParsing\";\r\nimport debug from \"../common/debugger\";\r\n\r\nexport const disassembleOgg = (data: Uint8Array, isChunk: boolean): OpusStream => {\r\n    const oggStart = isChunk ? 0 : findOggStart(data);\r\n    if (oggStart === -1) {\r\n        throw new Error('No Ogg data found');\r\n    }\r\n\r\n    if (oggStart > 0) {\r\n        debug.debugLog(`Skipping ${oggStart} bytes of non-Ogg data at start`);\r\n    }\r\n\r\n    const frames: OpusFrame[] = [];\r\n    let offset = oggStart;\r\n    let pageCount = 0;\r\n    let serialNumber: number | undefined;\r\n    let channels = 1;\r\n    let preskip = 312;\r\n    let sampleRate = 48000;\r\n    let lastGranule = BigInt(0);\r\n\r\n    while (offset < data.length) {\r\n        const page = parseOggPage(data, offset);\r\n        if (!page) {\r\n            debug.debugLog(`Failed to parse Ogg page at offset ${offset}`);\r\n            break;\r\n        }\r\n\r\n        if (pageCount === 0 && !isChunk) {\r\n            // Parse OpusHead for metadata\r\n            serialNumber = page.serialNumber;\r\n            const bodyOffset = 27 + page.segments;\r\n            channels = data[offset + bodyOffset + 9];\r\n            const view = new DataView(data.buffer, data.byteOffset + offset + bodyOffset);\r\n            preskip = view.getUint16(10, true);\r\n            sampleRate = view.getUint32(12, true);\r\n            debug.debugLog(`OpusHead: channels=${channels}, preskip=${preskip}, sampleRate=${sampleRate}, serial=${serialNumber}`);\r\n        } else if (pageCount === 1 && !isChunk) {\r\n            // Skip OpusTags\r\n            debug.debugLog(`Skipping OpusTags page`);\r\n        } else {\r\n            // Data page - extract frame(s)\r\n            const bodyOffset = 27 + page.segments;\r\n            const bodyEnd = bodyOffset + page.bodySize;\r\n\r\n            // Calculate samples for this page\r\n            const currentGranule = page.granulePosition;\r\n            const samples = Number(currentGranule - lastGranule);\r\n            debug.debugLog(`Data page ${pageCount}: granule=${currentGranule}, samples=${samples}, size=${page.bodySize}`);\r\n\r\n            // For simplicity, treat entire page body as one frame\r\n            // (In reality, pages can contain multiple frames with lacing)\r\n            frames.push({\r\n                data: data.subarray(offset + bodyOffset, offset + bodyEnd),\r\n                samples: samples,\r\n            });\r\n\r\n            lastGranule = currentGranule;\r\n        }\r\n\r\n        offset += page.pageSize;\r\n        pageCount++;\r\n    }\r\n\r\n    debug.debugLog(`Disassembled ${frames.length} frames from Ogg, total granule: ${lastGranule}`);\r\n\r\n    return {\r\n        frames,\r\n        serialNumber,\r\n        channels,\r\n        preskip,\r\n        sampleRate,\r\n    };\r\n};","/**\r\n * Known Matroska/WebM element IDs\r\n */\r\nexport const EBML_IDS = {\r\n    // Containers:\r\n    EBML: BigInt(\"0x1A45DFA3\"),\r\n    Segment: BigInt(\"0x18538067\"),\r\n    Tracks: BigInt(\"0x1654AE6B\"),\r\n    TrackEntry: BigInt(\"0xAE\"),\r\n    Cluster: BigInt(\"0x1F43B675\"),\r\n    BlockGroup: BigInt(\"0xA0\"),\r\n\r\n    // Leaves:\r\n    SimpleBlock: BigInt(\"0xA3\"),\r\n    CodecID: BigInt(\"0x86\"),\r\n    ChannelCount: BigInt(\"0x9F\"),\r\n    SamplingFrequency: BigInt(\"0xB5\"),\r\n    TrackNumber: BigInt(\"0xD7\"),\r\n}\r\n\r\nexport enum LACING_TYPES {\r\n    NONE = 0,\r\n    XIPH = 1,\r\n    FIXED_SIZE = 2,\r\n    EBML = 3,\r\n};","import debug from \"../common/debugger\";\r\nimport { LACING_TYPES } from \"./EBMLTypes\";\r\n\r\nconst debugLog = (...args: any[]) => debug.debugLog('parser', ...args);\r\n\r\n/**\r\n * Read EBML variable-length integer (VINT)\r\n * First byte encodes both the length and part of the value\r\n */\r\nexport const readVINT = (data: Uint8Array, offset: number, isId = false): { value: bigint, size: number, isUnknown: boolean } => {\r\n    let firstByte = data[offset];\r\n\r\n    // 1. Determine width\r\n    const width = Math.clz32(firstByte) - 24 + 1; // Number of leading zero bits + 1\r\n\r\n    if (width < 1) {\r\n        throw new Error(\"Invalid EBML VINT width\");\r\n    }\r\n\r\n    // 2. Clear the marker bit if not an ID\r\n    if (!isId) {\r\n        const markerBit = 1 << (8 - width);\r\n        firstByte &= ~markerBit;\r\n    }\r\n\r\n    let value = BigInt(firstByte);\r\n\r\n    // 3. Append subsequent bytes\r\n    for (let i = 1; i < width; i++) {\r\n        value = (value << BigInt(8)) | BigInt(data[offset + i]);\r\n    }\r\n\r\n    // 4. Check for \"All 1s\" (Unknown Length)\r\n    const maxValue = (BigInt(1) << BigInt(width * 7)) - BigInt(1);\r\n    const isUnknown = value === maxValue\r\n\r\n    debugLog(`Read VINT at offset ${offset}: value=${value}, size=${width}, isUnknown=${isUnknown}, bytes=[\\n${Array.from(data.subarray(offset, offset + width)).map(b => b.toString(16).padStart(2, '0')).join(' ')}\\n]`);\r\n\r\n    return {\r\n        value,\r\n        size: width,\r\n        isUnknown,\r\n    };\r\n};\r\n\r\nexport const readId = (data: Uint8Array, offset: number) =>\r\n    readVINT(data, offset, true);\r\n\r\nexport const decodeString = (data: Uint8Array, offset: number, length: number): string =>\r\n    new TextDecoder(\"utf-8\").decode(data.subarray(offset, offset + length))\r\n        .replace(/\\0/g, ''); // EBML strings are sometimes null-terminated (0x00) inside the buffer.\r\n\r\nconst decodeSignedVint = (value: bigint, width: number): bigint => {\r\n    // This is essentially calculating half the max value for the given width\r\n    const range = (BigInt(1) << BigInt(7 * width - 1)) - BigInt(1);\r\n    return value - range;\r\n};\r\n\r\nexport const processSimpleBlock = (data: Uint8Array, lacingType: number): Uint8Array[] => {\r\n    if (lacingType === LACING_TYPES.NONE) {\r\n        debugLog(`SimpleBlock with no lacing, single frame of size ${data.length} bytes`);\r\n        return [data];\r\n    }\r\n    const numFrames = data[0] + 1;\r\n    let offset = 1;\r\n    const frameSizes: number[] = [];\r\n\r\n    if (lacingType === LACING_TYPES.FIXED_SIZE) {\r\n        const totalSize = data.length - 1;\r\n        const frameSize = Math.floor(totalSize / numFrames);\r\n        for (let i = 0; i < numFrames; i++) {\r\n            frameSizes.push(frameSize);\r\n        }\r\n    } else {\r\n        switch (lacingType) {\r\n            case LACING_TYPES.XIPH:\r\n                for (let i = 0; i < numFrames - 1; i++) {\r\n                    let size = 0;\r\n                    let byte = 255;\r\n                    while (byte === 255) {\r\n                        byte = data[offset++];\r\n                        size += byte;\r\n                    }\r\n                    frameSizes.push(size);\r\n                }\r\n                break;\r\n            case LACING_TYPES.EBML:\r\n                // First size is absolute\r\n                let { value: firstSize, size: firstSizeLen } = readVINT(data, offset);\r\n                offset += firstSizeLen;\r\n                frameSizes.push(Number(firstSize));\r\n\r\n                // Subsequent sizes are signed differences\r\n                let previousSize = firstSize;\r\n                for (let i = 1; i < numFrames - 1; i++) {\r\n                    let { value: sizeDiffRaw, size: sizeDiffLen } = readVINT(data, offset);\r\n                    offset += sizeDiffLen;\r\n                    // Convert from \"EBML signed integer\" to normal signed integer\r\n                    const sizeDiff = BigInt(decodeSignedVint(sizeDiffRaw, sizeDiffLen));\r\n                    const frameSize = previousSize + sizeDiff;\r\n                    frameSizes.push(Number(frameSize));\r\n                    previousSize = frameSize;\r\n                }\r\n                break;\r\n        }\r\n        // Last frame size is whatever remains\r\n        const totalKnownSizes = frameSizes.reduce((a, b) => a + b, 0);\r\n        const lastFrameSize = data.length - offset - totalKnownSizes;\r\n        frameSizes.push(lastFrameSize);\r\n    }\r\n    const frames: Uint8Array[] = [];\r\n    for (const frameSize of frameSizes) {\r\n        const frameData = data.subarray(offset, offset + frameSize);\r\n        frames.push(frameData);\r\n        offset += frameSize;\r\n    }\r\n\r\n    debugLog(`SimpleBlock with lacing type ${LACING_TYPES[lacingType]}, ${numFrames} frames, sizes=[${frameSizes.join(', ')}]`);\r\n    return frames;\r\n};\r\n\r\n","export const getOpusSamples = (opusPacket: Uint8Array): number => {\r\n    const toc = opusPacket[0];\r\n    const config = (toc >> 3) & 0x1F;\r\n\r\n    // Frame sizes based on config (simplified)\r\n    const frameSizes = [\r\n        480, 960, 1920, 2880,  // SILK-only (NB)\r\n        480, 960, 1920, 2880,  // SILK-only (MB)\r\n        480, 960, 1920, 2880,  // SILK-only (WB)\r\n        480, 960, 1920, 2880,  // Hybrid (SWB)\r\n        480, 960, 1920, 2880,  // Hybrid (FB)\r\n        120, 240, 480, 960,    // CELT-only (NB)\r\n        120, 240, 480, 960,    // CELT-only (WB)\r\n        120, 240, 480, 960,    // CELT-only (SWB)\r\n        120, 240, 480, 960,    // CELT-only (FB)\r\n    ];\r\n\r\n    return frameSizes[config] || 960; // Fallback to 20ms\r\n};","import { OpusFrame, OpusStream } from \"../types/opus\";\r\nimport { EBML_IDS, LACING_TYPES } from \"./EBMLTypes\";\r\nimport { decodeString, processSimpleBlock, readId, readVINT } from \"./webmParse\";\r\nimport debug from \"../common/debugger\";\r\nimport { getOpusSamples } from \"../opus/opusParsing\";\r\n\r\nconst debugLog = (...args: any[]) => debug.debugLog('disassembler', ...args);\r\n\r\nexport const disassembleWebM = (data: Uint8Array, isChunk: boolean): OpusStream => {\r\n    debugLog('Extracting WebM frames');\r\n    const { frames: webMFrames, channels, sampleRate } = extractFramesAndMeta(data, isChunk);\r\n    debugLog(`Extracted ${webMFrames.length} WebM frames`);\r\n\r\n    // Extract codec info from WebM (simplified - assume defaults)\r\n    const preskip = 312; // Default Opus preskip in WebM if not specified, usually 312 samples\r\n    // (20ms at 48kHz), rarely different.\r\n\r\n    debugLog(`Using channels=${channels}, preskip=${preskip}, sampleRate=${sampleRate}`);\r\n\r\n    // Convert to OpusFrame format used by OpusStream\r\n    const frames: OpusFrame[] = webMFrames.map(frame => ({\r\n        data: frame,\r\n        samples: getOpusSamples(frame), // WebM doesn't store this, assume 20ms frames\r\n    }));\r\n\r\n    debugLog(`Converted to ${frames.length} Opus frames`);\r\n    debugLog(`Returning Opus stream with channels=${channels}, preskip=${preskip}, sampleRate=${sampleRate}`);\r\n    return {\r\n        frames,\r\n        channels,\r\n        preskip,\r\n        sampleRate,\r\n    };\r\n};\r\n\r\n/**\r\n * Extract Opus frames from a WebM/Matroska file\r\n */\r\nexport const extractFramesAndMeta = (buffer: Uint8Array, isChunk: boolean): { frames: Uint8Array[], channels: number, sampleRate: number } => {\r\n    const parentEnds = [buffer.length];\r\n    const frames: Uint8Array[] = [];\r\n    let offset = 0;\r\n    let currentTrackEntryNo = -1;\r\n    let opusTrackNo = -1;\r\n    let elementsCount = 0;\r\n    let channels = 1;\r\n    let sampleRate = 48000;\r\n\r\n    while (parentEnds.length > 0) {\r\n        elementsCount++;\r\n\r\n        const currentEnd = parentEnds[parentEnds.length - 1];\r\n\r\n        // 1. Check if we've finished the current container\r\n        if (offset >= currentEnd) {\r\n            parentEnds.pop();\r\n            continue;\r\n        }\r\n\r\n        // 2. Read element ID and size\r\n        const id = readId(buffer, offset);\r\n        const elementSize = readVINT(buffer, offset + id.size);\r\n        const dataStart = offset + id.size + elementSize.size;\r\n\r\n        // 3. Determine the end of this element\r\n        // if size is unknown, we assume it goes to the end of the parent\r\n        // so it inherits the parent's end\r\n        const dataEnd = elementSize.isUnknown\r\n            ? currentEnd\r\n            : dataStart + Number(elementSize.value);\r\n\r\n        // 4. Decision based on element ID:\r\n        // Enter, Process, or Skip\r\n        switch (id.value) {\r\n            // --- CONTAINERS: Enter (Push to stack and continue to the body) ---\r\n            case EBML_IDS.EBML:\r\n            case EBML_IDS.Segment:\r\n            case EBML_IDS.Tracks:\r\n            case EBML_IDS.TrackEntry:\r\n            case EBML_IDS.Cluster:\r\n                parentEnds.push(dataEnd);\r\n                offset = dataStart;\r\n                debugLog(`Entering container ID 0x${id.value.toString(16)} at offset ${offset}, ends at ${dataEnd}`);\r\n                break;\r\n\r\n            // --- LEAF ELEMENTS WITH REQUIRED DATA (Process) ---\r\n\r\n            // Metadata needed to interpret Opus frames:\r\n            case EBML_IDS.TrackNumber:\r\n                // Note current TrackNumber (inside TrackEntry, for CodecID lookup)\r\n                const trackNo = readVINT(buffer, dataStart); // Value is a VINT\r\n                currentTrackEntryNo = Number(trackNo.value);\r\n                offset = dataEnd;\r\n                debugLog(`Found TrackEntry number: ${currentTrackEntryNo}`);\r\n                break;\r\n\r\n            case EBML_IDS.CodecID:\r\n                // Check if this TrackEntry is Opus\r\n                const codec = decodeString(buffer, dataStart, Number(elementSize.value));\r\n                if (codec === \"A_OPUS\") {\r\n                    opusTrackNo = currentTrackEntryNo;\r\n                    debugLog(`Identified Opus track number: ${opusTrackNo}`);\r\n                }\r\n                offset = dataEnd;\r\n                debugLog(`Processed CodecID: ${codec} for TrackEntry number: ${currentTrackEntryNo}`);\r\n                break;\r\n\r\n            case EBML_IDS.ChannelCount:\r\n                if (currentTrackEntryNo !== opusTrackNo) {\r\n                    offset = dataEnd;\r\n                    debugLog(`Skipping ChannelCount for non-Opus TrackEntry number: ${currentTrackEntryNo}`);\r\n                    break;\r\n                }\r\n                channels = Number(readVINT(buffer, dataStart).value);\r\n                offset = dataEnd;\r\n                debugLog(`Processed ChannelCount: ${channels} for TrackEntry number: ${currentTrackEntryNo}`);\r\n                break;\r\n\r\n            case EBML_IDS.SamplingFrequency:\r\n                if (currentTrackEntryNo !== opusTrackNo) {\r\n                    offset = dataEnd;\r\n\r\n                    debugLog(`Skipping SamplingFrequency for non-Opus TrackEntry number: ${currentTrackEntryNo}`);\r\n                    break;\r\n                }\r\n                sampleRate = Number(readVINT(buffer, dataStart).value);\r\n                offset = dataEnd;\r\n                debugLog(`Processed SamplingFrequency: ${sampleRate} for TrackEntry number: ${currentTrackEntryNo}`);\r\n                break;\r\n\r\n            // Actual Opus frame data:\r\n            case EBML_IDS.SimpleBlock:\r\n                offset = dataEnd;\r\n                // Process SimpleBlock frame (extract if Opus frames)\r\n                debugLog(`Processing SimpleBlock at offset ${dataStart}`);\r\n                if (!isChunk && opusTrackNo === -1) {\r\n                    debugLog(`No Opus track identified yet, skipping SimpleBlock`);\r\n                    break;\r\n                }\r\n\r\n                const blockTrackNo = readVINT(buffer, dataStart);\r\n\r\n                debugLog(`SimpleBlock TrackNumber: ${blockTrackNo.value}, Opus TrackNumber: ${opusTrackNo}`);\r\n\r\n                if (!isChunk && Number(blockTrackNo.value) !== opusTrackNo)\r\n                    break;\r\n\r\n                const flags = buffer[dataStart + blockTrackNo.size + 2];\r\n                const lacingType = (flags & 0x06) >> 1;\r\n\r\n                debugLog(`SimpleBlock lacing type: ${lacingType} ( ${LACING_TYPES[lacingType]})`);\r\n\r\n                // Skip header: TrackNo VINT + 2 (Timecode) + 1 (Flags)\r\n                const blockDataStart = dataStart + blockTrackNo.size + 2 + 1;\r\n                const blockDataEnd = dataEnd;\r\n\r\n                const newFrames = processSimpleBlock(buffer.subarray(blockDataStart, blockDataEnd), lacingType);\r\n\r\n                debugLog(`Extracted ${newFrames.length} frames from SimpleBlock`);\r\n\r\n                frames.push(...newFrames);\r\n                break;\r\n\r\n            // --- ANYTHING ELSE (Skip) ---\r\n            default:\r\n                debugLog(`Skipping unrecognized element ID 0x${id.value.toString(16)} at offset ${offset}, size=${elementSize.value}${elementSize.isUnknown ? ' (unknown size)' : ''}`);\r\n                if (elementSize.isUnknown) {\r\n                    // If we hit an unknown-sized element we don't recognize, \r\n                    // we are forced to treat it as a container to look for IDs we DO know.\r\n                    parentEnds.push(dataEnd);\r\n                } else {\r\n                    offset = dataEnd;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    debugLog(`Total elements processed: ${elementsCount}`);\r\n\r\n    if (opusTrackNo === -1) {\r\n        debugLog(`Warning: No Opus track found in WebM file.`);\r\n    } else {\r\n        debugLog(`Opus track number: ${opusTrackNo}, channels: ${channels}, sampleRate: ${sampleRate}`);\r\n        debugLog(`Extracted ${frames.length} total Opus frames from WebM`);\r\n    }\r\n\r\n    return { frames, channels, sampleRate };\r\n}","export enum AudioFormat {\r\n    OGG_OPUS,\r\n    WEBM,\r\n    UNKNOWN,\r\n}","import { findOggStart } from \"../ogg/oggParsing\";\r\nimport { AudioFormat } from \"./audioTypes\";\r\n\r\nexport const detectFormat = (data: Uint8Array): AudioFormat => {\r\n    // Check for Ogg\r\n    const oggStart = findOggStart(data);\r\n    if (oggStart !== -1) {\r\n        return AudioFormat.OGG_OPUS;\r\n    }\r\n\r\n    // Check for WebM/Matroska EBML header (0x1A45DFA3)\r\n    if (data.length >= 4 &&\r\n        data[0] === 0x1A &&\r\n        data[1] === 0x45 &&\r\n        data[2] === 0xDF &&\r\n        data[3] === 0xA3) {\r\n        return AudioFormat.WEBM;\r\n    }\r\n\r\n    return AudioFormat.UNKNOWN;\r\n};","import { disassembleOgg } from \"../ogg/oggDisassemble\";\r\nimport { OpusStream } from \"../types/opus\";\r\nimport { disassembleWebM } from \"../webm/webmDisassemble\";\r\nimport { AudioFormat } from \"./audioTypes\";\r\nimport { detectFormat } from \"./formatDetection\";\r\nimport debug from \"./debugger\";\r\n\r\nconst debugLog = (...args: any[]) => debug.debugLog('disassembler', ...args);\r\n\r\n/**\r\n * Format-agnostic disassembly: detects format and extracts Opus frames\r\n * @param data - The input audio file data as a Uint8Array\r\n * @param chunkFormat - (Optional) Specify format if known (for chunks that may lack headers)\r\n * @returns An OpusStream containing extracted Opus frames and metadata\r\n */\r\nexport const disassembleOpusFile = (data: Uint8Array, chunkFormat?: AudioFormat): OpusStream => {\r\n    const isChunk = chunkFormat !== undefined;\r\n\r\n    const format = isChunk ? chunkFormat : detectFormat(data);\r\n    \r\n    debugLog(`Detected format: ${AudioFormat[format]}`);\r\n    \r\n    switch (format) {\r\n        case AudioFormat.OGG_OPUS:\r\n            return disassembleOgg(data, isChunk);\r\n        case AudioFormat.WEBM:\r\n            return disassembleWebM(data, isChunk);\r\n        case AudioFormat.UNKNOWN:\r\n            throw new Error('Unknown audio format (not Ogg Opus or WebM)');\r\n    }\r\n};","// CRC32 lookup table\r\nconst makeCRCTable = (): Uint32Array => {\r\n    const table = new Uint32Array(256);\r\n    for (let i = 0; i < 256; i++) {\r\n        let c = i << 24;\r\n        for (let j = 0; j < 8; j++) {\r\n            c = c & 0x80000000 ? (c << 1) ^ 0x04c11db7 : c << 1;\r\n        }\r\n        table[i] = c >>> 0;\r\n    }\r\n    return table;\r\n};\r\n\r\nconst crcTable: Uint32Array = makeCRCTable();\r\n\r\nexport const calculateCRC = (data: Uint8Array): number => {\r\n    let crc = 0;\r\n    for (let i = 0; i < data.length; i++) {\r\n        crc = ((crc << 8) ^ crcTable[((crc >>> 24) ^ data[i]) & 0xff]) >>> 0;\r\n    }\r\n    return crc;\r\n};","import { calculateCRC } from \"./oggCrc\";\r\n\r\n/**\r\n * Create a minimal OpusTags page with length/duration info omitted\r\n * @param serialNumber stream serial number\r\n * @param pageSequence page sequence number\r\n * @returns Uint8Array representing the OpusTags page\r\n */\r\nexport const createMinimalOpusTagsPage = (\r\n    serialNumber: number,\r\n    pageSequence: number,\r\n): Uint8Array => {\r\n    const vendorString = \"ogg-opus-concat\";\r\n    const vendorLength = vendorString.length;\r\n\r\n    // OpusTags structure:\r\n    // - \"OpusTags\" magic signature (8 bytes)\r\n    // - vendor string length (4 bytes, little-endian)\r\n    // - vendor string\r\n    // - user comment list length (4 bytes, little-endian) = 0\r\n    const bodySize = 8 + 4 + vendorLength + 4;\r\n    const body = new Uint8Array(bodySize);\r\n    let offset = 0;\r\n\r\n    // Magic signature\r\n    body.set(new TextEncoder().encode(\"OpusTags\"), offset);\r\n    offset += 8;\r\n\r\n    // Vendor string length (little-endian)\r\n    body[offset++] = vendorLength & 0xff;\r\n    body[offset++] = (vendorLength >> 8) & 0xff;\r\n    body[offset++] = (vendorLength >> 16) & 0xff;\r\n    body[offset++] = (vendorLength >> 24) & 0xff;\r\n\r\n    // Vendor string\r\n    body.set(new TextEncoder().encode(vendorString), offset);\r\n    offset += vendorLength;\r\n\r\n    // User comment list length = 0\r\n    body[offset++] = 0;\r\n    body[offset++] = 0;\r\n    body[offset++] = 0;\r\n    body[offset++] = 0;\r\n\r\n    // Create Ogg page with proper segment table\r\n    const segments = Math.ceil(bodySize / 255);\r\n    const segmentTable = new Uint8Array(segments);\r\n    for (let i = 0; i < segments - 1; i++) {\r\n        segmentTable[i] = 255;\r\n    }\r\n    segmentTable[segments - 1] = bodySize % 255 || 255;\r\n\r\n    const pageSize = 27 + segments + bodySize;\r\n    const page = new Uint8Array(pageSize);\r\n    const view = new DataView(page.buffer);\r\n\r\n    // OggS magic\r\n    page[0] = 0x4f;\r\n    page[1] = 0x67;\r\n    page[2] = 0x67;\r\n    page[3] = 0x53;\r\n\r\n    // Version\r\n    page[4] = 0;\r\n\r\n    // Header type (continuation of logical bitstream)\r\n    page[5] = 0x00;\r\n\r\n    // Granule position (0 for header)\r\n    view.setBigInt64(6, BigInt(0), true);\r\n\r\n    // Serial number\r\n    view.setUint32(14, serialNumber, true);\r\n\r\n    // Page sequence\r\n    view.setUint32(18, pageSequence, true);\r\n\r\n    // Checksum (will be calculated below)\r\n    view.setUint32(22, 0, true);\r\n\r\n    // Segments\r\n    page[26] = segments;\r\n\r\n    // Segment table\r\n    page.set(segmentTable, 27);\r\n\r\n    // Body\r\n    page.set(body, 27 + segments);\r\n\r\n    // Calculate and set checksum\r\n    const crc = calculateCRC(page);\r\n    view.setUint32(22, crc, true);\r\n\r\n    return page;\r\n};\r\n\r\n/**\r\n * Create an OpusHead identification header page\r\n */\r\nexport const createOpusHeadPage = (\r\n    serialNumber: number,\r\n    channels: number = 2,\r\n    preskip: number = 312, // Standard Opus pre-skip\r\n    sampleRate: number = 48000,\r\n): Uint8Array => {\r\n    // OpusHead structure (19 bytes):\r\n    // - \"OpusHead\" magic (8 bytes)\r\n    // - version (1 byte) = 1\r\n    // - channel count (1 byte)\r\n    // - pre-skip (2 bytes, little-endian)\r\n    // - input sample rate (4 bytes, little-endian)\r\n    // - output gain (2 bytes, little-endian) = 0\r\n    // - channel mapping family (1 byte) = 0\r\n    \r\n    const body = new Uint8Array(19);\r\n    const view = new DataView(body.buffer);\r\n    let offset = 0;\r\n    \r\n    // Magic signature\r\n    body.set(new TextEncoder().encode('OpusHead'), offset);\r\n    offset += 8;\r\n    \r\n    // Version\r\n    body[offset++] = 1;\r\n    \r\n    // Channel count\r\n    body[offset++] = channels;\r\n    \r\n    // Pre-skip\r\n    view.setUint16(offset, preskip, true);\r\n    offset += 2;\r\n    \r\n    // Input sample rate\r\n    view.setUint32(offset, sampleRate, true);\r\n    offset += 4;\r\n    \r\n    // Output gain\r\n    view.setInt16(offset, 0, true);\r\n    offset += 2;\r\n    \r\n    // Channel mapping family\r\n    body[offset++] = 0;\r\n    \r\n    // Create Ogg page\r\n    return createOggPage({\r\n        headerType: 0x02, // BOS (Beginning of Stream)\r\n        granulePosition: BigInt(0),\r\n        serialNumber,\r\n        pageSequence: 0,\r\n        body,\r\n    });\r\n};\r\n\r\n/**\r\n * Create an Ogg page from body data\r\n */\r\nexport const createOggPage = (options: {\r\n    headerType: number;\r\n    granulePosition: bigint;\r\n    serialNumber: number;\r\n    pageSequence: number;\r\n    body: Uint8Array;\r\n}): Uint8Array => {\r\n    const { headerType, granulePosition, serialNumber, pageSequence, body } = options;\r\n    \r\n    // Calculate segment table\r\n    const bodySize = body.length;\r\n    const fullSegments = Math.floor(bodySize / 255);\r\n    const lastSegmentSize = bodySize % 255;\r\n    const segments = fullSegments + (lastSegmentSize > 0 ? 1 : 0);\r\n    \r\n    const segmentTable = new Uint8Array(segments);\r\n    for (let i = 0; i < fullSegments; i++) {\r\n        segmentTable[i] = 255;\r\n    }\r\n    if (lastSegmentSize > 0) {\r\n        segmentTable[fullSegments] = lastSegmentSize;\r\n    }\r\n    \r\n    // Create page\r\n    const pageSize = 27 + segments + bodySize;\r\n    const page = new Uint8Array(pageSize);\r\n    const view = new DataView(page.buffer);\r\n    \r\n    // OggS magic\r\n    page[0] = 0x4f; // 'O'\r\n    page[1] = 0x67; // 'g'\r\n    page[2] = 0x67; // 'g'\r\n    page[3] = 0x53; // 'S'\r\n    \r\n    // Version\r\n    page[4] = 0;\r\n    \r\n    // Header type\r\n    page[5] = headerType;\r\n    \r\n    // Granule position\r\n    view.setBigInt64(6, granulePosition, true);\r\n    \r\n    // Serial number\r\n    view.setUint32(14, serialNumber, true);\r\n    \r\n    // Page sequence\r\n    view.setUint32(18, pageSequence, true);\r\n    \r\n    // Checksum (calculate later)\r\n    view.setUint32(22, 0, true);\r\n    \r\n    // Segment count\r\n    page[26] = segments;\r\n    \r\n    // Segment table\r\n    page.set(segmentTable, 27);\r\n    \r\n    // Body\r\n    page.set(body, 27 + segments);\r\n    \r\n    // Calculate and set checksum\r\n    const crc = calculateCRC(page);\r\n    view.setUint32(22, crc, true);\r\n    \r\n    return page;\r\n};\r\n\r\n/**\r\n * Calculate granule position for an Opus packet\r\n * Opus uses 48kHz sample rate, typical frame is 20ms = 960 samples\r\n */\r\nconst calculateOpusGranule = (packetIndex: number, samplesPerPacket: number = 960): bigint => {\r\n    return BigInt((packetIndex + 1) * samplesPerPacket);\r\n};\r\n\r\n/**\r\n * Wrap raw Opus packets into a complete Ogg Opus file\r\n */\r\nexport const wrapOpusPacketsInOgg = (\r\n    packets: Uint8Array[],\r\n    options?: {\r\n        channels?: number;\r\n        preskip?: number;\r\n        sampleRate?: number;\r\n        serialNumber?: number;\r\n    }\r\n): Uint8Array => {\r\n    const channels = options?.channels || 2;\r\n    const preskip = options?.preskip || 312;\r\n    const sampleRate = options?.sampleRate || 48000;\r\n    const serialNumber = options?.serialNumber || Math.floor(Math.random() * 0xFFFFFFFF);\r\n    \r\n    const pages: Uint8Array[] = [];\r\n    let pageSequence = 0;\r\n    \r\n    // Page 0: OpusHead\r\n    const opusHead = createOpusHeadPage(serialNumber, channels, preskip, sampleRate);\r\n    pages.push(opusHead);\r\n    pageSequence++;\r\n    \r\n    // Page 1: OpusTags (minimal)\r\n    const opusTags = createMinimalOpusTagsPage(serialNumber, pageSequence);\r\n    pages.push(opusTags);\r\n    pageSequence++;\r\n    \r\n    // Data pages: wrap packets\r\n    // Group multiple packets per page for efficiency (max ~4KB per page)\r\n    const MAX_PAGE_SIZE = 4000;\r\n    let currentPagePackets: Uint8Array[] = [];\r\n    let currentPageSize = 0;\r\n    \r\n    for (let i = 0; i < packets.length; i++) {\r\n        const packet = packets[i];\r\n        \r\n        // Check if adding this packet would exceed page size\r\n        if (currentPageSize + packet.length > MAX_PAGE_SIZE && currentPagePackets.length > 0) {\r\n            // Flush current page\r\n            const pageBody = new Uint8Array(currentPageSize);\r\n            let offset = 0;\r\n            for (const p of currentPagePackets) {\r\n                pageBody.set(p, offset);\r\n                offset += p.length;\r\n            }\r\n            \r\n            const granule = calculateOpusGranule(i - 1); // Granule of last packet in page\r\n            const page = createOggPage({\r\n                headerType: 0x00,\r\n                granulePosition: granule,\r\n                serialNumber,\r\n                pageSequence,\r\n                body: pageBody,\r\n            });\r\n            \r\n            pages.push(page);\r\n            pageSequence++;\r\n            \r\n            // Reset for next page\r\n            currentPagePackets = [];\r\n            currentPageSize = 0;\r\n        }\r\n        \r\n        currentPagePackets.push(packet);\r\n        currentPageSize += packet.length;\r\n    }\r\n    \r\n    // Flush remaining packets\r\n    if (currentPagePackets.length > 0) {\r\n        const pageBody = new Uint8Array(currentPageSize);\r\n        let offset = 0;\r\n        for (const p of currentPagePackets) {\r\n            pageBody.set(p, offset);\r\n            offset += p.length;\r\n        }\r\n        \r\n        const granule = calculateOpusGranule(packets.length - 1);\r\n        const page = createOggPage({\r\n            headerType: 0x04, // EOS (End of Stream) on last page\r\n            granulePosition: granule,\r\n            serialNumber,\r\n            pageSequence,\r\n            body: pageBody,\r\n        });\r\n        \r\n        pages.push(page);\r\n    }\r\n    \r\n    // Combine all pages\r\n    const totalSize = pages.reduce((sum, page) => sum + page.length, 0);\r\n    const result = new Uint8Array(totalSize);\r\n    let resultOffset = 0;\r\n    for (const page of pages) {\r\n        result.set(page, resultOffset);\r\n        resultOffset += page.length;\r\n    }\r\n    \r\n    return result;\r\n};","import { OpusStream } from \"../types/opus\";\r\nimport { createMinimalOpusTagsPage, createOggPage, createOpusHeadPage } from \"./oggWrite\";\r\nimport debug from \"../common/debugger\";\r\n\r\nconst { debugLog } = debug;\r\n\r\n/**\r\n * Assemble frames into appendable Ogg Opus file\r\n * @param stream \r\n * @param options \r\n * @returns \r\n */\r\nexport const assembleOgg = (stream: OpusStream, options: {\r\n    serialNumber?: number;\r\n    startingSequence?: number;\r\n    startingGranule?: bigint;\r\n    includeHeaders: boolean;\r\n}): { data: Uint8Array; pageCount: number; finalGranule: bigint } => {\r\n    const serialNumber = options?.serialNumber || stream.serialNumber || Math.floor(Math.random() * 0xFFFFFFFF);\r\n    const includeHeaders = options?.includeHeaders === undefined ? true : options?.includeHeaders;\r\n    let pageSequence = options?.startingSequence === undefined ? 0 : options?.startingSequence || 0;\r\n    let granule = options?.startingGranule === undefined ? BigInt(0) : options?.startingGranule || BigInt(0);\r\n\r\n    const pages: Uint8Array[] = [];\r\n    let pageCount = 0;\r\n\r\n    // Add headers if requested\r\n    if (includeHeaders) {\r\n        debugLog(`Creating OpusHead: serial=${serialNumber}, channels=${stream.channels}, preskip=${stream.preskip}, sampleRate=${stream.sampleRate}`);\r\n\r\n        pages.push(createOpusHeadPage(serialNumber, stream.channels, stream.preskip, stream.sampleRate));\r\n        pageSequence++;\r\n        pageCount++;\r\n\r\n        debugLog(`Creating minimal OpusTags: sequence=${pageSequence}`);\r\n\r\n        pages.push(createMinimalOpusTagsPage(serialNumber, pageSequence));\r\n        pageSequence++;\r\n        pageCount++;\r\n    } else {\r\n        debugLog(`Assembling data pages only (no headers), starting at sequence=${pageSequence}, granule=${granule}`);\r\n    }\r\n\r\n    // Add data pages\r\n    const MAX_PAGE_SIZE = 4000;\r\n    let currentPageData: Uint8Array[] = [];\r\n    let currentPageSize = 0;\r\n    let currentPageSamples = 0;\r\n\r\n    for (const frame of stream.frames) {\r\n        // Flush page if needed\r\n        if (currentPageSize + frame.data.length > MAX_PAGE_SIZE && currentPageData.length > 0) {\r\n            const pageBody = new Uint8Array(currentPageSize);\r\n\r\n            debugLog(`Flushing page: sequence=${pageSequence}, granule=${granule}, size=${pageBody.length}, packets=${currentPageData.length}`);\r\n\r\n            let offset = 0;\r\n            for (const d of currentPageData) {\r\n                pageBody.set(d, offset);\r\n                offset += d.length;\r\n            }\r\n\r\n            granule += BigInt(currentPageSamples);\r\n\r\n            const page = createOggPage({\r\n                headerType: 0x00,\r\n                granulePosition: granule,\r\n                serialNumber,\r\n                pageSequence,\r\n                body: pageBody,\r\n            });\r\n\r\n            pages.push(page);\r\n            pageSequence++;\r\n            pageCount++;\r\n\r\n            currentPageData = [];\r\n            currentPageSize = 0;\r\n            currentPageSamples = 0;\r\n        }\r\n\r\n        currentPageData.push(frame.data);\r\n        currentPageSize += frame.data.length;\r\n        currentPageSamples += frame.samples;\r\n    }\r\n\r\n    // Flush remaining\r\n    if (currentPageData.length > 0) {\r\n        const pageBody = new Uint8Array(currentPageSize);\r\n        let offset = 0;\r\n        for (const d of currentPageData) {\r\n            pageBody.set(d, offset);\r\n            offset += d.length;\r\n        }\r\n\r\n        granule += BigInt(currentPageSamples);\r\n\r\n        const page = createOggPage({\r\n            headerType: 0x00,\r\n            granulePosition: granule,\r\n            serialNumber,\r\n            pageSequence,\r\n            body: pageBody,\r\n        });\r\n\r\n        pages.push(page);\r\n        pageCount++;\r\n    }\r\n\r\n    // Combine pages\r\n    const totalSize = pages.reduce((sum, p) => sum + p.length, 0);\r\n    const data = new Uint8Array(totalSize);\r\n    let resultOffset = 0;\r\n    for (const page of pages) {\r\n        data.set(page, resultOffset);\r\n        resultOffset += page.length;\r\n    }\r\n\r\n    debugLog(`Assembled ${pageCount} pages, final granule: ${granule}, total size: ${data.length} bytes`);\r\n    \r\n    return { data, pageCount, finalGranule: granule };\r\n};","import { AudioFormat } from \"./common/audioTypes\";\r\nimport debug, { DebugCategory } from \"./common/debugger\";\r\nimport { disassembleOpusFile } from \"./common/disassemble\";\r\nimport { assembleOgg } from \"./ogg/oggAssemble\";\r\nimport { findOggStart, parseOggPage } from \"./ogg/oggParsing\";\r\n\r\nexport const setDebug = (enabled: boolean) => {\r\n    debug.isDebug = enabled;\r\n};\r\n\r\nexport const setDebugCategories = (categories: DebugCategory[]) => \r\n    debug.enabledCategories = new Set(categories);\r\n\r\n\r\nexport const setCustomDebugLogger = (logger: (...args: any[]) => void) => {\r\n    debug.customLogger = logger;\r\n};\r\n\r\nconst debugLog = (...args: any[]) => debug.debugLog('index', ...args);\r\n\r\n/**\r\n * Concatenate multiple Opus-in-Ogg or Opus-in-WebM files into a single logical bitstream.\r\n * Adjusts page headers, granule positions, and replaces OpusTags.\r\n */\r\nexport const concatChunks = (\r\n    chunks: Uint8Array[],\r\n): Uint8Array => {\r\n    if (chunks.length === 0) {\r\n        throw new Error('No chunks provided');\r\n    }\r\n\r\n    debugLog(`\\n=== Concatenating ${chunks.length} chunks ===`);\r\n\r\n    // First chunk - prepare it (auto-detects Ogg or WebM)\r\n    let { result, meta } = prepareAccumulator(chunks[0]);\r\n\r\n    debugLog(`First chunk prepared: ${result.length} bytes, granule=${meta.cumulativeGranule}`);\r\n\r\n    if (chunks.length === 1) {\r\n        return result;\r\n    }\r\n\r\n    // Remaining chunks - add them (auto-detects each)\r\n    ({ result } = appendToAccumulator(result, chunks.slice(1), meta));\r\n\r\n    debugLog(`Final result: ${result.length} bytes\\n`);\r\n\r\n    return result;\r\n};\r\n\r\nexport interface AccumulatorState {\r\n    serialNumber: number;\r\n    lastPageSequence: number;\r\n    cumulativeGranule: bigint;\r\n    totalSize: number;\r\n}\r\n\r\n/**\r\n * Parse and prepare an existing Opus file (Ogg or WebM container) for appending\r\n * Returns the prepared file (with EOS cleared, OpusTags replaced) and metadata\r\n * required for concatenation of more files within the same logical bitstream.\r\n */\r\nexport const prepareAccumulator = (\r\n    data: Uint8Array\r\n): { result: Uint8Array; meta: AccumulatorState } => {\r\n    debugLog(`\\n=== Preparing accumulator from ${data.length} byte file ===`);\r\n\r\n    // Disassemble (auto-detects format)\r\n    const stream = disassembleOpusFile(data);\r\n\r\n    // Assemble into clean Ogg with headers\r\n    const { data: result } = assembleOgg(stream, { includeHeaders: true });\r\n\r\n    // Extract metadata from the prepared file\r\n    const oggStart = findOggStart(result);\r\n    let offset = oggStart;\r\n    let lastPageSequence = 0;\r\n    let maxGranule = BigInt(0);\r\n    let serialNumber = stream.serialNumber || 0;\r\n\r\n    while (offset < result.length) {\r\n        const page = parseOggPage(result, offset);\r\n        if (!page) break;\r\n\r\n        if (serialNumber === 0) serialNumber = page.serialNumber;\r\n        lastPageSequence = page.pageSequence;\r\n        if (page.granulePosition > maxGranule) {\r\n            maxGranule = page.granulePosition;\r\n        }\r\n\r\n        offset += page.pageSize;\r\n    }\r\n\r\n    debugLog(`Prepared accumulator: serial=${serialNumber}, lastSeq=${lastPageSequence}, granule=${maxGranule}, size=${result.length}`);\r\n\r\n    return {\r\n        result,\r\n        meta: {\r\n            serialNumber,\r\n            lastPageSequence,\r\n            cumulativeGranule: maxGranule,\r\n            totalSize: result.length,\r\n        }\r\n    };\r\n};\r\n\r\n/**\r\n * Append new files (complete containers) to an existing accumulator\r\n * @param acc File to append to\r\n * @param files additional files to append, `.opus` (opus-in-ogg) files\r\n * @param accMeta Metadata about the current accumulator state\r\n * @param chunkFormat Format if using chunks, for chunks lack headers\r\n * @returns Updated accumulator (concatenated Opus file ready for further appending) and metadata for next append\r\n */\r\nexport const appendToAccumulator = (\r\n    acc: Uint8Array,\r\n    files: Uint8Array[],\r\n    accMeta: AccumulatorState,\r\n    chunkFormat?: AudioFormat,\r\n): { result: Uint8Array; meta: AccumulatorState } => {\r\n    debugLog(`\\n=== Appending ${files.length} chunks to accumulator ===`);\r\n    debugLog(`Starting state: seq=${accMeta.lastPageSequence}, granule=${accMeta.cumulativeGranule}, size=${accMeta.totalSize}`);\r\n\r\n    const dataPages: Uint8Array[] = [];\r\n    let pageSequence = accMeta.lastPageSequence + 1;\r\n    let granule = accMeta.cumulativeGranule;\r\n\r\n    for (let i = 0; i < files.length; i++) {\r\n        const chunk = files[i];\r\n        debugLog(`\\n--- Processing chunk ${i + 1}/${files.length} (${chunk.length} bytes) ---`);\r\n\r\n        // Disassemble chunk (auto-detects format for full files, uses chunkFormat for chunks)\r\n        const stream = disassembleOpusFile(chunk, chunkFormat);\r\n\r\n        // Assemble into data pages only (no headers)\r\n        const { data: chunkData, pageCount, finalGranule } = assembleOgg(stream, {\r\n            serialNumber: accMeta.serialNumber,\r\n            startingSequence: pageSequence,\r\n            startingGranule: granule,\r\n            includeHeaders: false,\r\n        });\r\n\r\n        dataPages.push(chunkData);\r\n\r\n        // Update state\r\n        granule = finalGranule;\r\n        pageSequence += pageCount;\r\n        debugLog(`Chunk assembled: ${pageCount} pages, granule advanced to ${finalGranule}`);\r\n    }\r\n\r\n    // Combine accumulator + new data\r\n    const totalSize = acc.length + dataPages.reduce((sum, p) => sum + p.length, 0);\r\n    const result = new Uint8Array(totalSize);\r\n    result.set(acc, 0);\r\n\r\n    let offset = acc.length;\r\n    for (const page of dataPages) {\r\n        result.set(page, offset);\r\n        offset += page.length;\r\n    }\r\n\r\n    debugLog(`\\nFinal state: seq=${pageSequence - 1}, granule=${granule}, total size=${result.length}`);\r\n\r\n    return {\r\n        result,\r\n        meta: {\r\n            serialNumber: accMeta.serialNumber,\r\n            lastPageSequence: pageSequence - 1,\r\n            cumulativeGranule: granule,\r\n            totalSize: result.length,\r\n        }\r\n    };\r\n};"],"mappings":"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","names":["LACING_TYPES","debugLog","AudioFormat","debugLog","debugLog","debugLog"]}